<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tsugie マップ</title>
    <link rel="stylesheet" href="./main-screen.css" />
    <script src="./local-config.js"></script>
  </head>
  <body>
    <main class="phone-frame" aria-label="Tsugie ホーム試作">
      <div class="top-controls">
        <button id="openCalendarButton" class="open-calendar-button" type="button" aria-label="時めぐりカレンダーを開く">
          時めぐり
        </button>
        <button id="locateButton" class="locate-button" type="button" aria-label="現在地へ戻る">⌖</button>
        <button
          class="top-kaomoji"
          type="button"
          aria-label="メニューを開く"
          aria-haspopup="true"
          aria-expanded="false"
        >
          (ᵔ◡ᵔ)
        </button>
      </div>
      <div id="sideDrawerLayer" class="side-drawer-layer" aria-hidden="true">
        <button id="sideDrawerBackdrop" class="side-drawer-backdrop" type="button" aria-label="メニューを閉じる"></button>
        <aside id="favoriteDrawer" class="favorite-drawer" aria-label="行きたい栞ドロワー" aria-hidden="true">
          <header class="favorite-drawer-header">
            <p class="favorite-drawer-title">行きたい栞</p>
            <button id="closeFavoriteDrawer" class="close-favorite-drawer" type="button" aria-label="栞ドロワーを閉じる">×</button>
          </header>
          <section id="favoriteDrawerContent" class="favorite-drawer-content" aria-live="polite"></section>
        </aside>
        <aside id="sideDrawer" class="side-drawer" aria-label="サイドメニュー">
          <header class="side-drawer-header">
            <p class="side-drawer-title">つぎへ ナビ</p>
            <div class="side-drawer-head-actions">
              <button
                id="toggleThemePalette"
                class="theme-toggle-pill"
                type="button"
                aria-label="配色を選ぶ"
                aria-expanded="false"
                aria-controls="themePalettePanel"
              ></button>
              <button id="closeSideDrawer" class="close-side-drawer" type="button" aria-label="メニューを閉じる">×</button>
            </div>
          </header>
          <section id="themePalettePanel" class="theme-palette-panel" aria-label="配色テーマ">
            <button class="theme-chip is-active" type="button" data-theme-scheme="fresh" aria-label="清爽ミント"></button>
            <button class="theme-chip" type="button" data-theme-scheme="ocean" aria-label="青空オーシャン"></button>
            <button class="theme-chip" type="button" data-theme-scheme="sunset" aria-label="夕焼けシトラス"></button>
            <button class="theme-chip" type="button" data-theme-scheme="sakura" aria-label="桜ローズ"></button>
            <button class="theme-chip" type="button" data-theme-scheme="night" aria-label="夜霧インク"></button>
            <div class="theme-adjusters" aria-label="色調整">
              <label class="theme-adjuster-row" for="themeAlphaRatioRange">
                <span class="theme-adjuster-label">透過比率</span>
                <input id="themeAlphaRatioRange" class="theme-adjuster-range" type="range" min="70" max="130" step="1" value="100" />
                <span id="themeAlphaRatioValue" class="theme-adjuster-value">100%</span>
              </label>
              <label class="theme-adjuster-row" for="themeSaturationRange">
                <span class="theme-adjuster-label">彩度</span>
                <input id="themeSaturationRange" class="theme-adjuster-range" type="range" min="70" max="150" step="1" value="100" />
                <span id="themeSaturationValue" class="theme-adjuster-value">100%</span>
              </label>
            </div>
          </section>
          <nav class="side-drawer-nav" aria-label="メニュー項目">
            <button class="side-drawer-item" data-menu-id="favorites" type="button">
              <span class="side-item-pill" aria-hidden="true"></span>
              <span class="side-item-text">行きたい栞</span>
            </button>
            <button class="side-drawer-item" data-menu-id="notifications" type="button">
              <span class="side-item-pill" aria-hidden="true"></span>
              <span class="side-item-text">知らせの灯</span>
            </button>
            <button class="side-drawer-item" data-menu-id="contact" type="button">
              <span class="side-item-pill" aria-hidden="true"></span>
              <span class="side-item-text">ことづて</span>
            </button>
          </nav>
          <section id="sideDrawerContent" class="side-drawer-content" aria-live="polite"></section>
        </aside>
      </div>
      <section class="map-stage" aria-label="地図とスポット">
        <div id="googleMap" class="google-map" role="img" aria-label="地図"></div>
        <div class="map-tint" aria-hidden="true"></div>
        <div id="fallbackLayer" class="fallback-layer" hidden></div>
        <div id="markerActionBubble" class="marker-action-bubble" hidden aria-live="polite"></div>
        <p id="mapHint" class="map-hint" hidden></p>
      </section>

      <section id="nearbyCarousel" class="nearby-carousel" aria-label="近くのスポット" aria-hidden="false">
        <div id="nearbyTrack" class="nearby-track"></div>
      </section>

      <section id="quickCard" class="quick-card" aria-live="polite" aria-hidden="true">
        <div class="sheet-grabber" aria-hidden="true"></div>
        <div class="quick-header">
          <p class="quick-tag">⚡ 最速攻略</p>
          <div class="quick-head-actions">
            <span id="quickStateIcons" class="place-state-icons place-state-icons-quick" aria-label="地点ステータス"></span>
            <button id="closeQuickCard" class="close-card" type="button" aria-label="クイック表示を閉じる">×</button>
          </div>
        </div>
        <div class="quick-title-row">
          <h2 id="quickTitle" class="quick-title">隅田川花火大会</h2>
          <p id="quickDuration" class="quick-duration">19:20 - 20:35</p>
        </div>
        <div id="quickProgress" class="quick-progress quick-progress-upcoming" aria-hidden="true">
          <div id="quickProgressTrack" class="quick-progress-track status-track">
            <span id="quickProgressFill" class="quick-progress-fill status-fill"></span>
            <span id="quickProgressEndpoint" class="quick-progress-endpoint status-endpoint">
              <span class="status-he">へ</span>
            </span>
            <span id="quickProgressFace" class="quick-progress-face status-face">(=˘ω˘=) zZ</span>
          </div>
        </div>
        <p id="quickMeta" class="quick-meta">0.8km ・ 本日開催！まもなく！</p>
        <p id="quickHint" class="quick-hint">✨ (ง •̀_•́)ง いま出発が最適</p>
        <div class="quick-actions">
          <button id="openDetailButton" class="secondary-button" type="button">詳細を見る</button>
          <button class="cta-button" type="button">ルートを開始</button>
        </div>
      </section>

      <section id="detailPanel" class="detail-panel" aria-label="への詳細" aria-hidden="true">
        <div id="detailGrabber" class="detail-grabber" aria-hidden="true"></div>
        <header class="detail-header">
          <p class="detail-label">へ 詳細</p>
          <button id="closeDetailButton" class="close-detail" type="button" aria-label="詳細を閉じる">⌄</button>
        </header>
        <div id="detailContent" class="detail-content">
          <div class="detail-name-row">
            <h2 id="detailName" class="detail-name">隅田川花火大会</h2>
            <span id="detailStateIcons" class="place-state-icons place-state-icons-detail" aria-label="地点ステータス"></span>
          </div>
          <div class="detail-meta-row">
            <span id="detailDistance" class="detail-distance">0.8km</span>
            <span id="detailOpenHours" class="detail-open-hours">開放時間 19:20 - 20:30</span>
          </div>

          <section id="detailProgressSection" class="detail-progress detail-progress-upcoming">
            <div class="detail-progress-head">
              <p id="detailProgressTitle" class="detail-progress-title">開始までの時間軸</p>
              <p id="detailProgressMeta" class="detail-progress-meta">あと42分</p>
            </div>
            <div id="detailProgressTrack" class="detail-progress-track status-track">
              <span id="detailProgressFill" class="detail-progress-fill status-fill"></span>
              <span id="detailProgressEndpoint" class="detail-progress-endpoint status-endpoint">
                <span class="status-he">へ</span>
              </span>
              <span id="detailProgressFace" class="detail-progress-face status-face">(=˘ω˘=) zZ</span>
            </div>
            <div class="detail-progress-foot">
              <span id="detailProgressLeft" class="detail-progress-left">いま</span>
              <span id="detailProgressRight" class="detail-progress-right">開始 19:20</span>
            </div>
          </section>

          <div id="detailHero" class="detail-hero">
            <span id="detailHeroBadge" class="detail-hero-badge">花火</span>
            <p id="detailHeroHint" class="detail-hero-hint">川沿いの視界が広く、写真映えしやすいエリア</p>
          </div>

          <section class="detail-mini-map">
            <div class="detail-mini-map-head">
              <p class="detail-mini-map-title">マップ上の位置</p>
              <button id="detailFocusButton" class="detail-focus-button" type="button">フォーカス</button>
            </div>
            <p id="detailMiniMapText" class="detail-mini-map-text">隅田川テラス側、南西エリア</p>
          </section>

          <section class="detail-section">
            <h3 class="detail-section-title">紹介</h3>
            <p id="detailDescription" class="detail-description">
              川面に広がる花火を、橋上と河岸の両方から楽しめる定番スポットです。
            </p>
          </section>

          <section class="detail-section">
            <h3 class="detail-section-title">いまの空気感</h3>
            <div class="detail-stats">
              <div class="detail-stat">
                <div class="detail-stat-head">
                  <span>熱度</span>
                  <span id="detailHeatValue">82</span>
                </div>
                <div class="detail-stat-bar"><span id="detailHeatBar"></span></div>
              </div>
              <div class="detail-stat">
                <div class="detail-stat-head">
                  <span>驚喜度</span>
                  <span id="detailSurpriseValue">76</span>
                </div>
                <div class="detail-stat-bar"><span id="detailSurpriseBar"></span></div>
              </div>
            </div>
          </section>
        </div>
      </section>

      <section id="calendarPanel" class="calendar-panel" aria-label="時間軸カレンダー" aria-hidden="true">
        <header class="calendar-header">
          <div>
            <p class="calendar-label">時めぐりカレンダー</p>
            <p class="calendar-semantic-note">時間軸のへ統計（マップは位置軸）</p>
          </div>
          <button id="closeCalendarButton" class="close-calendar" type="button" aria-label="カレンダーを閉じる">⌄</button>
        </header>
        <div id="calendarList" class="calendar-list"></div>
        <div id="calendarDayDrawerLayer" class="calendar-day-drawer-layer" aria-hidden="true">
          <button
            id="calendarDayDrawerBackdrop"
            class="calendar-day-drawer-backdrop"
            type="button"
            aria-label="日付の詳細を閉じる"
          ></button>
          <aside id="calendarDayDrawer" class="calendar-day-drawer" aria-label="日付ごとのへ一覧">
            <header class="calendar-day-drawer-header">
              <p id="calendarDayDrawerTitle" class="calendar-day-drawer-title">日付のへ</p>
              <button id="closeCalendarDayDrawer" class="close-calendar-day-drawer" type="button" aria-label="閉じる">×</button>
            </header>
            <div id="calendarDayDrawerContent" class="calendar-day-drawer-content"></div>
          </aside>
        </div>
      </section>
    </main>

    <script>
      const config = window.__TSUGIE_CONFIG__ || {};
      const phoneFrame = document.querySelector('.phone-frame');
      const mapRoot = document.getElementById('googleMap');
      const fallbackLayer = document.getElementById('fallbackLayer');
      const mapHint = document.getElementById('mapHint');

      const quickCard = document.getElementById('quickCard');
      const quickTitle = document.getElementById('quickTitle');
      const quickDuration = document.getElementById('quickDuration');
      const quickProgress = document.getElementById('quickProgress');
      const quickProgressTrack = document.getElementById('quickProgressTrack');
      const quickProgressFill = document.getElementById('quickProgressFill');
      const quickProgressEndpoint = document.getElementById('quickProgressEndpoint');
      const quickProgressFace = document.getElementById('quickProgressFace');
      const quickStateIcons = document.getElementById('quickStateIcons');
      const quickMeta = document.getElementById('quickMeta');
      const quickHint = document.getElementById('quickHint');
      const closeQuickCard = document.getElementById('closeQuickCard');
      const openDetailButton = document.getElementById('openDetailButton');

      const detailPanel = document.getElementById('detailPanel');
      const detailGrabber = document.getElementById('detailGrabber');
      const detailContent = document.getElementById('detailContent');
      const detailName = document.getElementById('detailName');
      const detailDistance = document.getElementById('detailDistance');
      const detailOpenHours = document.getElementById('detailOpenHours');
      const detailStateIcons = document.getElementById('detailStateIcons');
      const detailProgressSection = document.getElementById('detailProgressSection');
      const detailProgressTitle = document.getElementById('detailProgressTitle');
      const detailProgressMeta = document.getElementById('detailProgressMeta');
      const detailProgressTrack = document.getElementById('detailProgressTrack');
      const detailProgressFill = document.getElementById('detailProgressFill');
      const detailProgressEndpoint = document.getElementById('detailProgressEndpoint');
      const detailProgressFace = document.getElementById('detailProgressFace');
      const detailProgressLeft = document.getElementById('detailProgressLeft');
      const detailProgressRight = document.getElementById('detailProgressRight');
      const detailHero = document.getElementById('detailHero');
      const detailHeroBadge = document.getElementById('detailHeroBadge');
      const detailHeroHint = document.getElementById('detailHeroHint');
      const detailMiniMapText = document.getElementById('detailMiniMapText');
      const detailDescription = document.getElementById('detailDescription');
      const detailHeatValue = document.getElementById('detailHeatValue');
      const detailSurpriseValue = document.getElementById('detailSurpriseValue');
      const detailHeatBar = document.getElementById('detailHeatBar');
      const detailSurpriseBar = document.getElementById('detailSurpriseBar');
      const detailFocusButton = document.getElementById('detailFocusButton');
      const closeDetailButton = document.getElementById('closeDetailButton');
      const nearbyCarousel = document.getElementById('nearbyCarousel');
      const nearbyTrack = document.getElementById('nearbyTrack');
      const topKaomoji = document.querySelector('.top-kaomoji');
      const sideDrawerLayer = document.getElementById('sideDrawerLayer');
      const sideDrawerBackdrop = document.getElementById('sideDrawerBackdrop');
      const closeSideDrawer = document.getElementById('closeSideDrawer');
      const favoriteDrawer = document.getElementById('favoriteDrawer');
      const favoriteDrawerContent = document.getElementById('favoriteDrawerContent');
      const closeFavoriteDrawer = document.getElementById('closeFavoriteDrawer');
      const toggleThemePalette = document.getElementById('toggleThemePalette');
      const themePalettePanel = document.getElementById('themePalettePanel');
      const themeChips = Array.from(document.querySelectorAll('.theme-chip'));
      const themeAlphaRatioRange = document.getElementById('themeAlphaRatioRange');
      const themeAlphaRatioValue = document.getElementById('themeAlphaRatioValue');
      const themeSaturationRange = document.getElementById('themeSaturationRange');
      const themeSaturationValue = document.getElementById('themeSaturationValue');
      const sideDrawerItems = Array.from(document.querySelectorAll('.side-drawer-item'));
      const sideDrawerContent = document.getElementById('sideDrawerContent');
      const locateButton = document.getElementById('locateButton');
      const markerActionBubble = document.getElementById('markerActionBubble');
      const openCalendarButton = document.getElementById('openCalendarButton');
      const calendarPanel = document.getElementById('calendarPanel');
      const closeCalendarButton = document.getElementById('closeCalendarButton');
      const calendarList = document.getElementById('calendarList');
      const calendarDayDrawerLayer = document.getElementById('calendarDayDrawerLayer');
      const calendarDayDrawerBackdrop = document.getElementById('calendarDayDrawerBackdrop');
      const closeCalendarDayDrawerButton = document.getElementById('closeCalendarDayDrawer');
      const calendarDayDrawerTitle = document.getElementById('calendarDayDrawerTitle');
      const calendarDayDrawerContent = document.getElementById('calendarDayDrawerContent');

      const places = [
        {
          id: 'sumida-fireworks',
          name: '隅田川花火大会',
          lat: 35.7152,
          lng: 139.7996,
          testTimeline: {
            mode: 'upcoming',
            startInSec: 28 * 60,
            durationSec: 100 * 60
          },
          startTime: '19:20',
          endTime: '20:35',
          openHours: '18:40 - 20:35',
          imageTag: '花火',
          imageHint: '川沿いの視界が広く、写真映えしやすいエリア',
          mapSpot: '隅田川テラス南西、橋の手前エリア',
          description:
            '川面に広がる花火を、橋上と河岸の両方から楽しめる定番スポット。混雑ピーク前に入ると視界を確保しやすい。',
          heat: 88,
          surprise: 81,
          hint: '✨ (ง •̀_•́)ง いま出発が最適',
          markerX: '84px',
          markerY: '262px',
          recommended: true
        },
        {
          id: 'asakusa-samba',
          name: '浅草サンバ祭',
          lat: 35.7148,
          lng: 139.795,
          testTimeline: {
            mode: 'ongoing',
            elapsedSec: 30 * 60,
            durationSec: 90 * 60
          },
          startTime: '19:45',
          endTime: '21:10',
          openHours: '19:00 - 21:10',
          imageTag: '祭り',
          imageHint: '雷門側から音と光が集まる熱量高めのルート',
          mapSpot: '雷門通り側、通行規制エリア手前',
          description:
            '浅草の夜を彩るリズム系イベント。進行ルート沿いで観ると迫力があり、早めの立ち位置確保が鍵。',
          heat: 84,
          surprise: 75,
          hint: '(•̀ᴗ•́)و ルートは浅草通りが最短',
          markerX: '210px',
          markerY: '300px'
        },
        {
          id: 'meguro-sakura',
          name: '目黒川さくら並木',
          lat: 35.637,
          lng: 139.702,
          testTimeline: {
            mode: 'ended',
            endedAgoSec: 18 * 60,
            durationSec: 110 * 60
          },
          startTime: '20:10',
          endTime: '22:00',
          openHours: '17:00 - 22:00',
          imageTag: '夜桜',
          imageHint: '川沿い照明で淡いピンクが強く出る時間帯',
          mapSpot: '中目黒駅側から北へ 300m 区間',
          description:
            '川沿いの散策と軽い食べ歩きに向くスポット。ピーク直前の時間帯は写真を撮りやすく回遊もしやすい。',
          heat: 72,
          surprise: 86,
          hint: '(ᵔ◡ᵔ) 夕方の光で写真がきれい',
          markerX: '122px',
          markerY: '420px'
        },
        {
          id: 'jingu-icho',
          name: '神宮外苑いちょう並木',
          lat: 35.6764,
          lng: 139.7166,
          testTimeline: {
            mode: 'upcoming',
            startInSec: 30 * 60 * 60,
            durationSec: 80 * 60
          },
          startTime: '20:30',
          endTime: '21:50',
          openHours: '16:30 - 21:50',
          imageTag: '並木',
          imageHint: '歩道広め、回遊しながら楽しめるライン',
          mapSpot: '青山通り側エントランス付近',
          description:
            '広い歩道で回遊しやすく、混雑時でも流れが作りやすい定番ルート。夕方から夜にかけて雰囲気が変わる。',
          heat: 68,
          surprise: 73,
          hint: '(๑•̀ㅂ•́)و 広い歩道で回遊しやすい',
          markerX: '202px',
          markerY: '510px'
        }
      ];

      const colorPairs = [
        ['#00CEC9', '#00CEC9'],
        ['#00B894', '#55EFC4'],
        ['#55EFC4', '#FDCB6E'],
        ['#E17055', '#E17055'],
        ['#DFE6E9', '#D63031'],
        ['#A29BFE', '#E84393'],
        ['#DFE6E9', '#6C5CE7'],
        ['#0984E3', '#74B9FF']
      ];
      const kaomojiPool = ['(ᵔ◡ᵔ)', '(•̀ᴗ•́)و', '(๑•̀ㅂ•́)و', '(ง •̀_•́)ง', '(˶ᵔ ᵕ ᵔ˶)', '(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧'];
      const defaultPlaceStates = {
        'sumida-fireworks': { favorite: true, checkedIn: false },
        'asakusa-samba': { favorite: true, checkedIn: true },
        'jingu-icho': { favorite: true, checkedIn: false }
      };

      const markerHandles = new Map();
      const testTimelineCache = new Map();
      let mapInstance = null;
      let autoOpenTimer = null;
      let autoOpenScheduled = false;
      let currentFocusPlaceId = '';
      let currentDetailPlaceId = '';
      let currentLocationMarker = null;
      let currentLocationPulseTimer = null;
      let currentLocationPosition = null;
      let statusTicker = null;
      let quickSwipeState = null;
      let detailSwipeState = null;
      let suppressDetailUntil = 0;
      let activeMenuId = '';
      let activeColorScheme = 'fresh';
      let activeThemeAlphaRatio = 1;
      let activeThemeSaturation = 1;
      let calendarDayFilter = 'all';
      let calendarDayKey = '';
      let favoriteDrawerFilter = 'all';
      let markerBubbleInfoWindow = null;
      const markerBubbleState = {
        placeId: '',
        mode: '',
        anchor: null
      };
      const PLACE_STATE_STORAGE_KEY = 'tsugie.placeState.v1';
      const placeStateMap = new Map();
      const sideDrawerState = {
        worldMode: false,
        notifications: {
          start: true,
          nearby: false
        }
      };
      const calendarCategoryDefs = [
        { key: 'all', label: '全部', logo: '◎' },
        { key: 'hanabi', label: '花火', logo: '花' },
        { key: 'matsuri', label: '祭典', logo: '祭' },
        { key: 'nature', label: '景観', logo: '景' },
        { key: 'other', label: 'その他', logo: '他' }
      ];
      const COLOR_SCHEME_STORAGE_KEY = 'tsugie.colorScheme';
      const THEME_ALPHA_RATIO_STORAGE_KEY = 'tsugie.themeAlphaRatio';
      const THEME_SATURATION_STORAGE_KEY = 'tsugie.themeSaturationRatio';
      const THEME_TOKEN_KEYS = [
        '--theme-accent-1',
        '--theme-accent-2',
        '--theme-accent-3',
        '--theme-pill-1',
        '--theme-pill-2',
        '--theme-pill-3',
        '--theme-map-glow',
        '--theme-drawer-bg-1',
        '--theme-drawer-bg-2',
        '--theme-drawer-bg-3'
      ];
      const CALENDAR_MONTHS_BEFORE = 1;
      const CALENDAR_MONTHS_AFTER = 5;
      const DEFAULT_STREET_ZOOM = 15;
      // Test phase: keep current location fixed near Sumida / Tokyo Skytree.
      const fallbackCurrentLocation = {
        lat: 35.710063,
        lng: 139.8107,
        markerX: 'calc(50% - 8px)',
        markerY: 'calc(58% - 8px)'
      };

      const mapStyle = [
        { featureType: 'poi', stylers: [{ visibility: 'off' }] },
        { featureType: 'transit', stylers: [{ visibility: 'off' }] },
        { featureType: 'road.highway', elementType: 'geometry', stylers: [{ color: '#ffffff' }] },
        { featureType: 'road.arterial', elementType: 'geometry', stylers: [{ color: '#f7fcff' }] },
        { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#cbe9ff' }] },
        { featureType: 'landscape', elementType: 'geometry', stylers: [{ color: '#eefaf4' }] }
      ];

      function showHint(text) {
        mapHint.hidden = false;
        mapHint.textContent = text;
      }

      function hideHint() {
        mapHint.hidden = true;
        mapHint.textContent = '';
      }

      function normalizeHex(hex) {
        const cleaned = String(hex || '').replace('#', '').trim();
        return cleaned.length === 6 ? `#${cleaned}` : '#00B894';
      }

      function withAlpha(hex, alphaHex) {
        const cleaned = normalizeHex(hex).replace('#', '');
        return `#${cleaned}${alphaHex}`;
      }

      function hexToRgb(hex) {
        const normalized = normalizeHex(hex).replace('#', '');
        const value = Number.parseInt(normalized, 16);
        if (!Number.isFinite(value)) return { r: 0, g: 0, b: 0 };
        return {
          r: (value >> 16) & 255,
          g: (value >> 8) & 255,
          b: value & 255
        };
      }

      function mixRgb(a, b, ratio) {
        const t = Math.max(0, Math.min(1, Number(ratio) || 0));
        return {
          r: Math.round(a.r + (b.r - a.r) * t),
          g: Math.round(a.g + (b.g - a.g) * t),
          b: Math.round(a.b + (b.b - a.b) * t)
        };
      }

      function rgbaText(rgb, alpha) {
        const safeAlpha = Math.max(0, Math.min(1, Number(alpha) || 0));
        return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${safeAlpha.toFixed(3)})`;
      }

      function clampNumber(value, min, max) {
        return Math.max(min, Math.min(max, Number(value) || 0));
      }

      function parseColorText(colorText) {
        const safe = String(colorText || '').trim();
        if (!safe) return null;
        if (safe.startsWith('#')) {
          const hex = safe.slice(1);
          if (hex.length === 3 || hex.length === 4) {
            const r = Number.parseInt(`${hex[0]}${hex[0]}`, 16);
            const g = Number.parseInt(`${hex[1]}${hex[1]}`, 16);
            const b = Number.parseInt(`${hex[2]}${hex[2]}`, 16);
            const a = hex.length === 4 ? Number.parseInt(`${hex[3]}${hex[3]}`, 16) / 255 : 1;
            return { r, g, b, a };
          }
          if (hex.length === 6 || hex.length === 8) {
            const r = Number.parseInt(hex.slice(0, 2), 16);
            const g = Number.parseInt(hex.slice(2, 4), 16);
            const b = Number.parseInt(hex.slice(4, 6), 16);
            const a = hex.length === 8 ? Number.parseInt(hex.slice(6, 8), 16) / 255 : 1;
            return { r, g, b, a };
          }
          return null;
        }
        const rgbMatch = safe.match(/^rgba?\(([^)]+)\)$/i);
        if (!rgbMatch) return null;
        const parts = rgbMatch[1].split(',').map((part) => part.trim());
        if (parts.length < 3) return null;
        const r = clampNumber(Number(parts[0]), 0, 255);
        const g = clampNumber(Number(parts[1]), 0, 255);
        const b = clampNumber(Number(parts[2]), 0, 255);
        const a = parts.length >= 4 ? clampNumber(Number(parts[3]), 0, 1) : 1;
        return { r: Math.round(r), g: Math.round(g), b: Math.round(b), a };
      }

      function rgbToHsl(rgb) {
        const r = clampNumber(rgb.r, 0, 255) / 255;
        const g = clampNumber(rgb.g, 0, 255) / 255;
        const b = clampNumber(rgb.b, 0, 255) / 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d = max - min;
        let h = 0;
        let s = 0;
        const l = (max + min) / 2;

        if (d !== 0) {
          s = d / (1 - Math.abs(2 * l - 1));
          switch (max) {
            case r:
              h = ((g - b) / d) % 6;
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            default:
              h = (r - g) / d + 4;
              break;
          }
        }
        h *= 60;
        if (h < 0) h += 360;
        return { h, s, l };
      }

      function hslToRgb(hsl) {
        const h = ((Number(hsl.h) % 360) + 360) % 360;
        const s = clampNumber(hsl.s, 0, 1);
        const l = clampNumber(hsl.l, 0, 1);
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = l - c / 2;
        let r = 0;
        let g = 0;
        let b = 0;

        if (h < 60) {
          r = c;
          g = x;
        } else if (h < 120) {
          r = x;
          g = c;
        } else if (h < 180) {
          g = c;
          b = x;
        } else if (h < 240) {
          g = x;
          b = c;
        } else if (h < 300) {
          r = x;
          b = c;
        } else {
          r = c;
          b = x;
        }

        return {
          r: Math.round((r + m) * 255),
          g: Math.round((g + m) * 255),
          b: Math.round((b + m) * 255)
        };
      }

      function adjustColorTone(colorText, saturationRatio, alphaRatio) {
        const parsed = parseColorText(colorText);
        if (!parsed) return colorText;
        const hsl = rgbToHsl(parsed);
        const rgb = hslToRgb({
          h: hsl.h,
          s: clampNumber(hsl.s * saturationRatio, 0, 1),
          l: hsl.l
        });
        const alpha = clampNumber(parsed.a * alphaRatio, 0, 1);
        return rgbaText(rgb, alpha);
      }

      const quickGlowStops = [
        { t: 0, c: '#18f3d0' },
        { t: 0.42, c: '#33d1ff' },
        { t: 0.72, c: '#8b8cff' },
        { t: 1, c: '#ff66c4' }
      ];

      function sampleQuickGradientColor(progress01) {
        const t = Math.max(0, Math.min(1, Number(progress01) || 0));
        for (let i = 0; i < quickGlowStops.length - 1; i += 1) {
          const left = quickGlowStops[i];
          const right = quickGlowStops[i + 1];
          if (t >= left.t && t <= right.t) {
            const local = (t - left.t) / Math.max(0.0001, right.t - left.t);
            return mixRgb(hexToRgb(left.c), hexToRgb(right.c), local);
          }
        }
        return hexToRgb(quickGlowStops[quickGlowStops.length - 1].c);
      }

      function applyQuickGlowColor(progress01) {
        if (!quickProgress) return;
        const sampled = sampleQuickGradientColor(progress01);
        const white = { r: 255, g: 255, b: 255 };
        const softTint = mixRgb(sampled, white, 0.74);
        const strongTint = mixRgb(sampled, white, 0.58);
        quickProgress.style.setProperty('--quick-glow-color', rgbaText(softTint, 0.34));
        quickProgress.style.setProperty('--quick-glow-color-strong', rgbaText(strongTint, 0.52));
      }

      function hashSeed(text) {
        let value = 0;
        const source = String(text || 'marker');
        for (let i = 0; i < source.length; i += 1) {
          value = (value * 31 + source.charCodeAt(i)) >>> 0;
        }
        return value;
      }

      function colorPair(name) {
        return colorPairs[hashSeed(name) % colorPairs.length];
      }

      function setMarkerActive(activeId) {
        markerHandles.forEach((handle, id) => {
          if (typeof handle.setActive === 'function') {
            handle.setActive(id === activeId);
          }
        });
      }

      function isDetailVisible() {
        return detailPanel.classList.contains('is-visible');
      }

      function findPlaceById(placeId) {
        return places.find((item) => item.id === placeId) || null;
      }

      function isSameLocalDate(a, b) {
        if (!(a instanceof Date) || Number.isNaN(a.getTime())) return false;
        if (!(b instanceof Date) || Number.isNaN(b.getTime())) return false;
        return (
          a.getFullYear() === b.getFullYear() &&
          a.getMonth() === b.getMonth() &&
          a.getDate() === b.getDate()
        );
      }

      function quickStartDateText(status) {
        const start = status && status.startDate instanceof Date ? status.startDate : null;
        if (!start || Number.isNaN(start.getTime())) return '日付未定';

        if (isSameLocalDate(start, new Date())) {
          return '本日開催！まもなく！';
        }

        const y = start.getFullYear();
        const m = String(start.getMonth() + 1).padStart(2, '0');
        const d = String(start.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }

      function resolvedDistanceText(place) {
        const origin = currentLocationPosition || fallbackCurrentLocation;
        const km = distanceKm(origin.lat, origin.lng, place.lat, place.lng);
        return formatDistanceLabel(km);
      }

      function quickDurationText(status) {
        if (!status) return '--:-- - --:--';
        return `${status.startLabel || '--:--'} - ${status.endLabel || '--:--'}`;
      }

      function quickMetaText(place, status) {
        const safeStatus = status || resolveEventStatus(place);
        const distance = resolvedDistanceText(place);
        const dateText = quickStartDateText(safeStatus);
        return `${distance} ・ ${dateText}`;
      }

      function markerBubbleMarkup(place) {
        if (!place) return '';
        const state = placeStateOf(place.id);
        return [
          `<div class="marker-action-bubble-inner" data-marker-bubble-place="${escapeHtml(place.id)}">`,
          '  <span class="marker-action-arc" aria-hidden="true"></span>',
          `  <button class="marker-action-button marker-action-favorite ${state.favorite ? 'is-on' : ''}" type="button" data-marker-action="favorite" data-place-id="${escapeHtml(place.id)}" aria-label="行きたいに留める">${state.favorite ? '★' : '☆'}</button>`,
          `  <button class="marker-action-button marker-action-open marker-action-quick" type="button" data-marker-action="quick" data-place-id="${escapeHtml(place.id)}" aria-label="クイック表示を開く">↗</button>`,
          `  <button class="marker-action-button marker-action-checkin ${state.checkedIn ? 'is-on' : ''}" type="button" data-marker-action="checkin" data-place-id="${escapeHtml(place.id)}" aria-label="訪問ずみとして記録">${state.checkedIn ? '◉' : '◌'}</button>`,
          `  <p class="marker-action-place">${escapeHtml(place.name)}</p>`,
          '</div>'
        ].join('');
      }

      function closeMarkerActionBubble() {
        const closingPlaceId = markerBubbleState.placeId;
        markerBubbleState.placeId = '';
        markerBubbleState.mode = '';
        markerBubbleState.anchor = null;
        if (markerActionBubble) {
          markerActionBubble.hidden = true;
          markerActionBubble.innerHTML = '';
        }
        if (markerBubbleInfoWindow) {
          markerBubbleInfoWindow.close();
        }
        if (!quickCard.classList.contains('is-visible') && !isDetailVisible() && closingPlaceId) {
          currentFocusPlaceId = '';
          currentDetailPlaceId = '';
          setMarkerActive('');
        }
      }

      function isMarkerActionBubbleOpen() {
        return Boolean(markerBubbleState.placeId);
      }

      function bindMarkerBubbleNode(node) {
        if (!node) return;
        node.addEventListener('click', (event) => {
          const actionButton = event.target.closest('[data-marker-action]');
          if (!actionButton) return;
          const action = actionButton.getAttribute('data-marker-action');
          const placeId = actionButton.getAttribute('data-place-id') || markerBubbleState.placeId;
          const place = findPlaceById(placeId);
          if (!place) return;

          if (action === 'favorite') {
            toggleFavoriteState(placeId);
            rerenderMarkerActionBubble();
            refreshAfterPlaceStateChange();
            return;
          }

          if (action === 'checkin') {
            toggleCheckinState(placeId);
            rerenderMarkerActionBubble();
            refreshAfterPlaceStateChange();
            return;
          }

          if (action === 'quick') {
            closeMarkerActionBubble();
            openQuickCard(place, 'marker-bubble');
          }
        });
      }

      function openFallbackMarkerBubble(place, markerElement) {
        if (!markerActionBubble || !markerElement) return;
        const markerRect = markerElement.getBoundingClientRect();
        const frameRect = phoneFrame.getBoundingClientRect();
        const x = markerRect.left - frameRect.left + markerRect.width / 2;
        const y = markerRect.top - frameRect.top - 8;
        markerActionBubble.style.setProperty('--bubble-x', `${x}px`);
        markerActionBubble.style.setProperty('--bubble-y', `${y}px`);
        markerActionBubble.innerHTML = markerBubbleMarkup(place);
        markerActionBubble.hidden = false;
        bindMarkerBubbleNode(markerActionBubble.querySelector('.marker-action-bubble-inner'));
      }

      function openGoogleMarkerBubble(place, googleMarker) {
        if (!mapInstance || !window.google || !window.google.maps || !googleMarker) return false;
        if (!markerBubbleInfoWindow) {
          markerBubbleInfoWindow = new window.google.maps.InfoWindow();
        }
        markerBubbleInfoWindow.setContent(markerBubbleMarkup(place));
        markerBubbleInfoWindow.open({
          map: mapInstance,
          anchor: googleMarker,
          shouldFocus: false
        });
        window.google.maps.event.addListenerOnce(markerBubbleInfoWindow, 'domready', () => {
          const node = document.querySelector('.marker-action-bubble-inner');
          bindMarkerBubbleNode(node);
        });
        return true;
      }

      function openMarkerActionBubble(place, anchorMode) {
        if (!place) return;
        closeMarkerActionBubble();
        if (isCalendarVisible()) {
          closeCalendarPanel();
        }
        currentFocusPlaceId = place.id;
        currentDetailPlaceId = place.id;
        setMarkerActive(place.id);
        markerBubbleState.placeId = place.id;
        markerBubbleState.mode = anchorMode === 'fallback' ? 'fallback' : 'google';

        const handle = markerHandles.get(place.id);
        markerBubbleState.anchor = handle || null;
        if (handle && handle.marker && openGoogleMarkerBubble(place, handle.marker)) {
          return;
        }
        openFallbackMarkerBubble(place, handle && handle.element ? handle.element : null);
      }

      function rerenderMarkerActionBubble() {
        const place = findPlaceById(markerBubbleState.placeId);
        if (!place) return;
        if (markerBubbleState.mode === 'google' && markerBubbleState.anchor && markerBubbleState.anchor.marker) {
          openGoogleMarkerBubble(place, markerBubbleState.anchor.marker);
          return;
        }
        if (markerBubbleState.anchor && markerBubbleState.anchor.element) {
          openFallbackMarkerBubble(place, markerBubbleState.anchor.element);
        }
      }

      function openQuickCard(place, source) {
        closeMarkerActionBubble();
        if (isCalendarVisible()) {
          closeCalendarPanel();
        }
        currentDetailPlaceId = place.id;
        const status = resolveEventStatus(place);
        quickTitle.textContent = place.name;
        quickDuration.textContent = quickDurationText(status);
        quickMeta.textContent = quickMetaText(place, status);
        quickHint.textContent = place.hint;
        applyPlaceStateIcons(quickStateIcons, place.id, 'quick');
        applyQuickProgress(status);
        quickCard.style.transform = '';
        quickCard.classList.remove('is-dragging');
        quickCard.classList.add('is-visible');
        quickCard.setAttribute('aria-hidden', 'false');
        currentFocusPlaceId = place.id;
        setMarkerActive(place.id);
        if (isDetailVisible()) {
          closeDetailPanel(false);
        }
        syncBottomPanels();

        const handle = markerHandles.get(place.id);
        if (handle && typeof handle.focus === 'function') handle.focus();
      }

      function closeQuickCardPanel() {
        resetQuickCardSwipe();
        quickCard.classList.remove('is-visible');
        quickCard.setAttribute('aria-hidden', 'true');
        closeMarkerActionBubble();
        currentFocusPlaceId = '';
        currentDetailPlaceId = '';
        setMarkerActive('');
        closeDetailPanel(false);
        renderNearbyCarousel();
        syncBottomPanels();
      }

      function applyDetailStats(heat, surprise) {
        const safeHeat = Math.max(0, Math.min(100, Number(heat) || 0));
        const safeSurprise = Math.max(0, Math.min(100, Number(surprise) || 0));
        detailHeatValue.textContent = `${safeHeat}`;
        detailSurpriseValue.textContent = `${safeSurprise}`;
        detailHeatBar.style.width = `${safeHeat}%`;
        detailSurpriseBar.style.width = `${safeSurprise}%`;
      }

      function setProgressAnchor(node, pct) {
        if (!node) return;
        node.classList.remove('is-edge-left', 'is-edge-right');
        if (pct <= 8) {
          node.classList.add('is-edge-left');
        } else if (pct >= 92) {
          node.classList.add('is-edge-right');
        }
      }

      function setProgressPosition(trackNode, fillNode, faceNode, endpointNode, pct) {
        const safePct = Math.max(0, Math.min(100, Number(pct) || 0));
        if (trackNode) trackNode.style.setProperty('--progress-pct', `${safePct}%`);
        if (fillNode) fillNode.style.width = `${safePct}%`;
        setProgressAnchor(faceNode, safePct);
        setProgressAnchor(endpointNode, safePct);
      }

      function applyQuickProgress(status) {
        if (!quickProgress || !quickProgressFace) return;
        quickProgress.classList.remove('quick-progress-ongoing', 'quick-progress-upcoming', 'quick-progress-ended');

        if (status.mode === 'ongoing') {
          const pct = Math.round(Math.max(0, Math.min(1, Number(status.progress) || 0)) * 100);
          quickProgress.classList.add('quick-progress-ongoing');
          quickProgressFace.textContent = '(=^･ω･^=)ﾉ';
          applyQuickGlowColor(pct / 100);
          setProgressPosition(quickProgressTrack, quickProgressFill, quickProgressFace, quickProgressEndpoint, pct);
          return;
        }

        if (status.mode === 'upcoming') {
          const pct = Math.round(Math.max(0, Math.min(1, Number(status.waitProgress) || 0)) * 100);
          quickProgress.classList.add('quick-progress-upcoming');
          quickProgressFace.textContent = '(=˘ω˘=) zZ';
          applyQuickGlowColor(0.08);
          setProgressPosition(quickProgressTrack, quickProgressFill, quickProgressFace, quickProgressEndpoint, pct);
          return;
        }

        if (status.mode === 'ended') {
          quickProgress.classList.add('quick-progress-ended');
          quickProgressFace.textContent = '(=•ω•=)';
          applyQuickGlowColor(0.96);
          setProgressPosition(quickProgressTrack, quickProgressFill, quickProgressFace, quickProgressEndpoint, 100);
          return;
        }

        quickProgress.classList.add('quick-progress-upcoming');
        quickProgressFace.textContent = '(=˘ω˘=)';
        applyQuickGlowColor(0.08);
        setProgressPosition(quickProgressTrack, quickProgressFill, quickProgressFace, quickProgressEndpoint, 8);
      }

      function applyDetailProgress(status) {
        const safeProgress = Math.max(0, Math.min(1, Number(status.progress) || 0));
        const safeWaitProgress = Math.max(0, Math.min(1, Number(status.waitProgress) || 0));

        if (status.mode === 'ongoing') {
          const pct = Math.round(safeProgress * 100);
          detailProgressSection.classList.remove('detail-progress-upcoming');
          detailProgressSection.classList.add('detail-progress-ongoing');
          detailProgressTitle.textContent = '活動進行度';
          detailProgressMeta.textContent = `進行中 ${pct}% ・ 残り${status.etaLabel}`;
          detailProgressLeft.textContent = `開始 ${status.startLabel}`;
          detailProgressRight.textContent = `終了 ${status.endLabel}`;
          detailProgressFace.textContent = '(=^･ω･^=)ﾉ';
          setProgressPosition(detailProgressTrack, detailProgressFill, detailProgressFace, detailProgressEndpoint, pct);
          return;
        }

        if (status.mode === 'upcoming') {
          const pct = Math.round(safeWaitProgress * 100);
          detailProgressSection.classList.remove('detail-progress-ongoing');
          detailProgressSection.classList.add('detail-progress-upcoming');
          detailProgressTitle.textContent = '開始までの時間軸';
          detailProgressMeta.textContent = status.etaLabel ? `あと${status.etaLabel}` : '開始時刻を確認中';
          detailProgressLeft.textContent = 'いま';
          detailProgressRight.textContent = `開始 ${status.startLabel}`;
          detailProgressFace.textContent = '(=˘ω˘=) zZ';
          setProgressPosition(detailProgressTrack, detailProgressFill, detailProgressFace, detailProgressEndpoint, pct);
          return;
        }

        if (status.mode === 'ended') {
          detailProgressSection.classList.remove('detail-progress-ongoing');
          detailProgressSection.classList.add('detail-progress-upcoming');
          detailProgressTitle.textContent = '活動ステータス';
          detailProgressMeta.textContent = '終了済み';
          detailProgressLeft.textContent = `開始 ${status.startLabel}`;
          detailProgressRight.textContent = `終了 ${status.endLabel}`;
          detailProgressFace.textContent = '(=•ω•=)';
          setProgressPosition(detailProgressTrack, detailProgressFill, detailProgressFace, detailProgressEndpoint, 100);
          return;
        }

        detailProgressSection.classList.remove('detail-progress-ongoing');
        detailProgressSection.classList.add('detail-progress-upcoming');
        detailProgressTitle.textContent = '時間情報';
        detailProgressMeta.textContent = '時刻未定';
        detailProgressLeft.textContent = 'いま';
        detailProgressRight.textContent = '開始 未定';
        detailProgressFace.textContent = '(=˘ω˘=)';
        setProgressPosition(detailProgressTrack, detailProgressFill, detailProgressFace, detailProgressEndpoint, 8);
      }

      function updateDetailPanel(place) {
        const pair = colorPair(place.name);
        const from = normalizeHex(pair[0]);
        const to = normalizeHex(pair[1]);
        const status = resolveEventStatus(place);

        detailName.textContent = place.name;
        detailDistance.textContent = resolvedDistanceText(place);
        detailOpenHours.textContent = `開放時間 ${place.openHours || `${place.startTime} - ${place.endTime || '未定'}`}`;
        detailMiniMapText.textContent = place.mapSpot || '地図上の中心エリア';
        detailDescription.textContent = place.description || place.hint || '';
        detailHeroBadge.textContent = place.imageTag || 'イベント';
        detailHeroHint.textContent = place.imageHint || '';
        applyPlaceStateIcons(detailStateIcons, place.id, 'detail');
        detailHero.style.setProperty('--hero-from', from);
        detailHero.style.setProperty('--hero-to', to);
        applyDetailStats(place.heat, place.surprise);
        applyDetailProgress(status);
      }

      function openDetailPanel(place, source) {
        if (Date.now() < suppressDetailUntil) return;
        if (isCalendarVisible()) return;
        closeMarkerActionBubble();
        closeCalendarPanel();
        closeSideDrawerPanel();
        updateDetailPanel(place);
        currentDetailPlaceId = place.id;
        currentFocusPlaceId = place.id;
        setMarkerActive(place.id);
        quickCard.classList.remove('is-visible');
        quickCard.setAttribute('aria-hidden', 'true');
        quickCard.style.transform = '';
        quickCard.classList.remove('is-dragging');
        detailPanel.classList.add('is-visible');
        detailPanel.classList.remove('is-dragging');
        detailPanel.style.transform = '';
        detailPanel.setAttribute('aria-hidden', 'false');
        detailContent.scrollTop = 0;
        phoneFrame.classList.add('is-detail-open');
        syncBottomPanels();
      }

      function forceHideDetailPanel() {
        resetDetailSwipe();
        detailPanel.classList.remove('is-visible');
        detailPanel.classList.remove('is-dragging');
        detailPanel.setAttribute('aria-hidden', 'true');
        detailPanel.style.transform = '';
        phoneFrame.classList.remove('is-detail-open');
      }

      function closeDetailPanel(restoreQuickCard) {
        const wasVisible =
          isDetailVisible() || detailPanel.getAttribute('aria-hidden') === 'false' || phoneFrame.classList.contains('is-detail-open');
        forceHideDetailPanel();
        syncBottomPanels();

        if (!wasVisible) return;

        if (restoreQuickCard && currentFocusPlaceId) {
          const place = findPlaceById(currentFocusPlaceId);
          if (place) {
            const status = resolveEventStatus(place);
            quickTitle.textContent = place.name;
            quickDuration.textContent = quickDurationText(status);
            quickMeta.textContent = quickMetaText(place, status);
            quickHint.textContent = place.hint;
            applyQuickProgress(status);
            quickCard.classList.add('is-visible');
            quickCard.setAttribute('aria-hidden', 'false');
            syncBottomPanels();
          }
        }
      }

      function focusPlaceOnMap(place, fromDetailPanel) {
        if (!place) return;
        if (mapInstance && window.google && window.google.maps) {
          mapInstance.panTo({ lat: place.lat, lng: place.lng });
          mapInstance.setZoom(Math.max(DEFAULT_STREET_ZOOM, 16));
        } else {
          showHint('Embed モードでは地図フォーカスの位置移動は固定されています。');
        }
        if (fromDetailPanel) {
          closeDetailPanel(true);
        }
      }

      function createMarkerElement(place) {
        const colors = colorPair(place.name);
        const from = colors[0];
        const to = colors[1];
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'he-marker is-fallback';
        button.setAttribute('aria-label', place.name);
        button.style.setProperty('--marker-from', normalizeHex(from));
        button.style.setProperty('--marker-to', normalizeHex(to));
        button.style.setProperty('--marker-halo', withAlpha(to, '3d'));
        button.style.setProperty('--x', place.markerX);
        button.style.setProperty('--y', place.markerY);

        button.innerHTML = [
          '<span class="marker-halo" aria-hidden="true"></span>',
          '<span class="marker-core" aria-hidden="true">へ</span>',
          `<span class="marker-label">${place.name}</span>`
        ].join('');
        button.addEventListener('click', () => openMarkerActionBubble(place, 'fallback'));
        return button;
      }

      function recommendedPlace() {
        return places.find((place) => place.recommended) || places[0];
      }

      function setRandomKaomoji() {
        if (!topKaomoji || !kaomojiPool.length) return;
        const random = kaomojiPool[Math.floor(Math.random() * kaomojiPool.length)];
        topKaomoji.textContent = random;
      }

      function setThemePaletteOpen(nextOpen) {
        if (!themePalettePanel || !toggleThemePalette) return;
        const open = Boolean(nextOpen);
        themePalettePanel.classList.toggle('is-open', open);
        toggleThemePalette.setAttribute('aria-expanded', open ? 'true' : 'false');
      }

      function toggleThemePalettePanel() {
        if (!themePalettePanel) return;
        setThemePaletteOpen(!themePalettePanel.classList.contains('is-open'));
      }

      function loadPersistedColorScheme() {
        try {
          const value = window.localStorage.getItem(COLOR_SCHEME_STORAGE_KEY);
          return value || '';
        } catch (error) {
          return '';
        }
      }

      function persistColorScheme(schemeId) {
        try {
          window.localStorage.setItem(COLOR_SCHEME_STORAGE_KEY, String(schemeId || 'fresh'));
        } catch (error) {
          // Ignore storage failures in private mode.
        }
      }

      function loadPersistedThemeRatio(key, fallback) {
        try {
          const raw = Number(window.localStorage.getItem(key));
          if (!Number.isFinite(raw)) return fallback;
          return clampNumber(raw, 0.7, 1.5);
        } catch (error) {
          return fallback;
        }
      }

      function persistThemeRatios() {
        try {
          window.localStorage.setItem(THEME_ALPHA_RATIO_STORAGE_KEY, String(activeThemeAlphaRatio));
          window.localStorage.setItem(THEME_SATURATION_STORAGE_KEY, String(activeThemeSaturation));
        } catch (error) {
          // Ignore storage failures.
        }
      }

      function setThemeRatioLabels() {
        if (themeAlphaRatioRange) {
          themeAlphaRatioRange.value = `${Math.round(activeThemeAlphaRatio * 100)}`;
        }
        if (themeSaturationRange) {
          themeSaturationRange.value = `${Math.round(activeThemeSaturation * 100)}`;
        }
        if (themeAlphaRatioValue) {
          themeAlphaRatioValue.textContent = `${Math.round(activeThemeAlphaRatio * 100)}%`;
        }
        if (themeSaturationValue) {
          themeSaturationValue.textContent = `${Math.round(activeThemeSaturation * 100)}%`;
        }
      }

      function applyThemeRatios() {
        const styles = window.getComputedStyle(phoneFrame);
        THEME_TOKEN_KEYS.forEach((tokenKey) => {
          const baseValue = styles.getPropertyValue(tokenKey).trim();
          const liveValue = adjustColorTone(baseValue, activeThemeSaturation, activeThemeAlphaRatio);
          const liveKey = tokenKey.replace('--theme-', '--theme-live-');
          phoneFrame.style.setProperty(liveKey, liveValue);
        });
      }

      function setThemeRatios(nextAlphaRatio, nextSaturationRatio, persist) {
        const alpha = clampNumber(nextAlphaRatio, 0.7, 1.3);
        const saturation = clampNumber(nextSaturationRatio, 0.7, 1.5);
        activeThemeAlphaRatio = alpha;
        activeThemeSaturation = saturation;
        setThemeRatioLabels();
        applyThemeRatios();
        if (persist !== false) {
          persistThemeRatios();
        }
      }

      function applyColorScheme(schemeId) {
        const safe = ['fresh', 'ocean', 'sunset', 'sakura', 'night'].includes(String(schemeId))
          ? String(schemeId)
          : 'fresh';
        activeColorScheme = safe;
        phoneFrame.setAttribute('data-color-scheme', safe);
        persistColorScheme(safe);
        themeChips.forEach((chip) => {
          chip.classList.toggle('is-active', chip.dataset.themeScheme === safe);
        });
        applyThemeRatios();
      }

      function escapeHtml(text) {
        return String(text || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function normalizePlaceState(rawState) {
        const raw = rawState && typeof rawState === 'object' ? rawState : {};
        return {
          favorite: Boolean(raw.favorite),
          checkedIn: Boolean(raw.checkedIn)
        };
      }

      function loadPersistedPlaceStates() {
        try {
          const raw = window.localStorage.getItem(PLACE_STATE_STORAGE_KEY);
          if (!raw) return {};
          const parsed = JSON.parse(raw);
          return parsed && typeof parsed === 'object' ? parsed : {};
        } catch (error) {
          return {};
        }
      }

      function persistPlaceStates() {
        try {
          const payload = {};
          placeStateMap.forEach((state, placeId) => {
            payload[placeId] = normalizePlaceState(state);
          });
          window.localStorage.setItem(PLACE_STATE_STORAGE_KEY, JSON.stringify(payload));
        } catch (error) {
          // Ignore storage failures.
        }
      }

      function initPlaceStates() {
        placeStateMap.clear();
        const stored = loadPersistedPlaceStates();
        places.forEach((place) => {
          const fallback = defaultPlaceStates[place.id] || {};
          const merged = Object.assign({}, fallback, stored[place.id] || {});
          placeStateMap.set(place.id, normalizePlaceState(merged));
        });
      }

      function placeStateOf(placeId) {
        if (!placeStateMap.has(placeId)) {
          placeStateMap.set(placeId, { favorite: false, checkedIn: false });
        }
        return normalizePlaceState(placeStateMap.get(placeId));
      }

      function setPlaceState(placeId, patch) {
        const prev = placeStateOf(placeId);
        const next = normalizePlaceState(Object.assign({}, prev, patch || {}));
        placeStateMap.set(placeId, next);
        persistPlaceStates();
      }

      function toggleFavoriteState(placeId) {
        const prev = placeStateOf(placeId);
        setPlaceState(placeId, { favorite: !prev.favorite });
      }

      function toggleCheckinState(placeId) {
        const prev = placeStateOf(placeId);
        const checkedIn = !prev.checkedIn;
        setPlaceState(placeId, { checkedIn, favorite: checkedIn ? true : prev.favorite });
      }

      function favoritePlaces() {
        return places.filter((place) => placeStateOf(place.id).favorite);
      }

      function placeStateIconsMarkup(placeId, variant) {
        const state = placeStateOf(placeId);
        const scope = variant || 'base';
        return [
          `<span class="place-state-icons place-state-icons-${scope}" data-place-state="${escapeHtml(placeId)}">`,
          `  <span class="state-logo state-logo-favorite ${state.favorite ? 'is-on' : ''}" aria-hidden="true">${state.favorite ? '★' : '☆'}</span>`,
          `  <span class="state-logo state-logo-checkin ${state.checkedIn ? 'is-on' : ''}" aria-hidden="true">${state.checkedIn ? '◉' : '◌'}</span>`,
          '</span>'
        ].join('');
      }

      function applyPlaceStateIcons(node, placeId, variant) {
        if (!node || !placeId) return;
        const shell = document.createElement('div');
        shell.innerHTML = placeStateIconsMarkup(placeId, variant);
        const rendered = shell.firstElementChild;
        if (!rendered) return;
        node.className = rendered.className;
        node.setAttribute('data-place-state', rendered.getAttribute('data-place-state') || placeId);
        node.setAttribute('aria-label', '地点ステータス');
        node.innerHTML = rendered.innerHTML;
      }

      function isCalendarVisible() {
        return Boolean(calendarPanel && calendarPanel.classList.contains('is-visible'));
      }

      function categoryForPlace(place) {
        const name = String(place && place.name ? place.name : '');
        const tag = String(place && place.imageTag ? place.imageTag : '');
        if (name.includes('花火') || tag.includes('花火')) return 'hanabi';
        if (name.includes('祭') || tag.includes('祭')) return 'matsuri';
        if (name.includes('桜') || name.includes('並木') || tag.includes('桜') || tag.includes('並木')) return 'nature';
        return 'other';
      }

      function categoryMeta(categoryKey) {
        return calendarCategoryDefs.find((item) => item.key === categoryKey) || calendarCategoryDefs[0];
      }

      function dayKeyOf(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }

      function dayTitleOf(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '日付未定';
        const week = ['日', '月', '火', '水', '木', '金', '土'];
        const m = date.getMonth() + 1;
        const d = date.getDate();
        return `${m}/${d} (${week[date.getDay()]})`;
      }

      function monthTitleOf(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '月未定';
        return `${date.getFullYear()}年${date.getMonth() + 1}月`;
      }

      function recommendationCompare(a, b) {
        if (!a || !b) return 0;
        const nowA = a.status && a.status.startDate instanceof Date ? a.status.startDate.getTime() : Number.MAX_SAFE_INTEGER;
        const nowB = b.status && b.status.startDate instanceof Date ? b.status.startDate.getTime() : Number.MAX_SAFE_INTEGER;
        const distDiff = (a.distanceKm || 9999) - (b.distanceKm || 9999);
        if (Math.abs(distDiff) > 0.01) return distDiff;
        if (nowA !== nowB) return nowA - nowB;
        return (b.place.heat || 0) - (a.place.heat || 0);
      }

      function scoredPlaces(sourcePlaces) {
        const origin = currentLocationPosition || fallbackCurrentLocation;
        return sourcePlaces.map((place) => {
          const status = resolveEventStatus(place);
          return {
            place,
            status,
            distanceKm: distanceKm(origin.lat, origin.lng, place.lat, place.lng),
            category: categoryForPlace(place),
            dayKey: dayKeyOf(status.startDate)
          };
        });
      }

      function buildCalendarBuckets() {
        const scored = scoredPlaces(places).filter((item) => item.dayKey);
        const bucketMap = new Map();
        scored.forEach((item) => {
          if (!bucketMap.has(item.dayKey)) {
            bucketMap.set(item.dayKey, {
              dayKey: item.dayKey,
              dayDate: item.status.startDate,
              items: [],
              counts: new Map()
            });
          }
          const bucket = bucketMap.get(item.dayKey);
          bucket.items.push(item);
          const prev = bucket.counts.get(item.category) || 0;
          bucket.counts.set(item.category, prev + 1);
        });

        const buckets = Array.from(bucketMap.values());
        buckets.forEach((bucket) => {
          bucket.items.sort(recommendationCompare);
          bucket.topTwo = bucket.items.slice(0, 2);
        });
        buckets.sort((a, b) => a.dayDate.getTime() - b.dayDate.getTime());
        return buckets;
      }

      function buildCalendarMonths(buckets) {
        if (!buckets.length) return [];
        const bucketMap = new Map(buckets.map((bucket) => [bucket.dayKey, bucket]));
        const firstDate = buckets[0].dayDate;
        const lastDate = buckets[buckets.length - 1].dayDate;
        const now = new Date();
        const todayMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
        const firstMonthStart = new Date(firstDate.getFullYear(), firstDate.getMonth(), 1);
        const lastMonthStart = new Date(lastDate.getFullYear(), lastDate.getMonth(), 1);
        const baselineStart = new Date(now.getFullYear(), now.getMonth() - CALENDAR_MONTHS_BEFORE, 1);
        const baselineEnd = new Date(now.getFullYear(), now.getMonth() + CALENDAR_MONTHS_AFTER, 1);
        const rangeStart = new Date(
          Math.min(firstMonthStart.getTime(), todayMonthStart.getTime(), baselineStart.getTime())
        );
        const rangeEnd = new Date(
          Math.max(lastMonthStart.getTime(), todayMonthStart.getTime(), baselineEnd.getTime())
        );
        const months = [];
        let cursor = new Date(rangeStart);
        const end = new Date(rangeEnd);

        while (cursor.getTime() <= end.getTime()) {
          const year = cursor.getFullYear();
          const month = cursor.getMonth();
          const firstWeekday = new Date(year, month, 1).getDay();
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          const cells = [];

          for (let i = 0; i < firstWeekday; i += 1) {
            cells.push({ type: 'blank' });
          }

          for (let day = 1; day <= daysInMonth; day += 1) {
            const date = new Date(year, month, day);
            const dayKey = dayKeyOf(date);
            cells.push({
              type: 'day',
              day,
              dayKey,
              date,
              bucket: bucketMap.get(dayKey) || null
            });
          }

          months.push({
            key: `${year}-${String(month + 1).padStart(2, '0')}`,
            title: monthTitleOf(cursor),
            cells
          });
          cursor = new Date(year, month + 1, 1);
        }
        return months;
      }

      function bucketByDayKey(dayKey) {
        return buildCalendarBuckets().find((bucket) => bucket.dayKey === dayKey) || null;
      }

      function isCalendarDayDrawerOpen() {
        return Boolean(calendarDayDrawerLayer && calendarDayDrawerLayer.classList.contains('is-open'));
      }

      function setCalendarDayDrawerOpen(nextOpen) {
        if (!calendarDayDrawerLayer) return;
        const open = Boolean(nextOpen);
        calendarDayDrawerLayer.classList.toggle('is-open', open);
        calendarDayDrawerLayer.setAttribute('aria-hidden', open ? 'false' : 'true');
      }

      function closeCalendarDayDrawer(resetSelection) {
        if (resetSelection) {
          calendarDayKey = '';
          calendarDayFilter = 'all';
        }
        setCalendarDayDrawerOpen(false);
      }

      function renderCalendarDayDrawerContent() {
        if (!calendarDayDrawerContent || !calendarDayDrawerTitle) return;
        const bucket = bucketByDayKey(calendarDayKey);
        if (!bucket) {
          calendarDayDrawerTitle.textContent = '日付のへ';
          calendarDayDrawerContent.innerHTML = '<p class="drawer-muted">選択した日のへはありません。</p>';
          return;
        }

        calendarDayDrawerTitle.textContent = `${dayTitleOf(bucket.dayDate)} のへ`;
        const categoryKeys = ['all']
          .concat(Array.from(bucket.counts.keys()))
          .filter((key, index, arr) => arr.indexOf(key) === index);
        const chips = categoryKeys
          .map((key) => {
            const meta = categoryMeta(key);
            const active = key === calendarDayFilter;
            const count = key === 'all' ? bucket.items.length : bucket.counts.get(key) || 0;
            return [
              `<button class="drawer-day-filter ${active ? 'is-active' : ''}" type="button" data-day-filter="${key}">`,
              `  <span class="drawer-day-filter-logo">${meta.logo}</span>`,
              `  <span>${meta.label}</span>`,
              `  <span class="drawer-day-filter-count">${count}</span>`,
              '</button>'
            ].join('');
          })
          .join('');

        const filtered = bucket.items.filter((item) => {
          if (calendarDayFilter === 'all') return true;
          return item.category === calendarDayFilter;
        });

        const rows = filtered
          .map((item) => {
            const meta = categoryMeta(item.category);
            const progress = miniProgressMarkup(item.status, 'day');
            const stateIcons = placeStateIconsMarkup(item.place.id, 'day');
            return [
              `<button class="drawer-day-item" type="button" data-day-place-id="${escapeHtml(item.place.id)}">`,
              '  <span class="drawer-day-item-main">',
              `    <span class="drawer-day-item-logo">${meta.logo}</span>`,
              '    <span class="drawer-day-item-copy">',
              `      <span class="drawer-day-item-name">${escapeHtml(item.place.name)}</span>`,
              `      <span class="drawer-day-item-meta">${formatDistanceLabel(item.distanceKm)} ・ ${item.status.startLabel} - ${item.status.endLabel}</span>`,
              '      <span class="drawer-day-item-countdown">',
              `        <span class="drawer-day-item-countdown-left">${item.status.leftLabel}</span>`,
              '      </span>',
              '    </span>',
              '    <span class="drawer-day-item-right">',
              `      <span class="drawer-day-item-tag">${meta.label}</span>`,
              `      ${stateIcons}`,
              '    </span>',
              '  </span>',
              `  ${progress}`,
              '</button>'
            ].join('');
          })
          .join('');

        calendarDayDrawerContent.innerHTML = [
          '<div class="drawer-section">',
          '  <p class="drawer-muted">時間軸から抽出。並び順は近さと開始の早さを優先。</p>',
          `  <div class="drawer-day-filters">${chips}</div>`,
          `  <div class="drawer-day-list">${rows || '<p class="drawer-muted">該当なし</p>'}</div>`,
          '</div>'
        ].join('');

        calendarDayDrawerContent.querySelectorAll('[data-day-filter]').forEach((button) => {
          button.addEventListener('click', () => {
            calendarDayFilter = button.getAttribute('data-day-filter') || 'all';
            renderCalendarDayDrawerContent();
          });
        });

        calendarDayDrawerContent.querySelectorAll('[data-day-place-id]').forEach((button) => {
          const place = findPlaceById(button.getAttribute('data-day-place-id') || '');
          if (place) {
            applyMiniProgressNode(button.querySelector('.mini-progress'), resolveEventStatus(place));
          }
          button.addEventListener('click', () => {
            const place = findPlaceById(button.getAttribute('data-day-place-id') || '');
            if (!place) return;
            closeCalendarDayDrawer(true);
            closeCalendarPanel();
            openQuickCard(place, 'calendar-day');
          });
        });
      }

      function openCalendarDayDrawer(dayKey) {
        if (!dayKey) return;
        calendarDayKey = dayKey;
        calendarDayFilter = 'all';
        renderCalendarDayDrawerContent();
        setCalendarDayDrawerOpen(true);
      }

      function renderCalendarPanel() {
        if (!calendarList) return;
        const buckets = buildCalendarBuckets();
        if (!buckets.length) {
          calendarList.innerHTML = '<p class="calendar-empty">この期間のへはありません。</p>';
          return;
        }

        const months = buildCalendarMonths(buckets);
        const today = new Date();
        const todayKey = dayKeyOf(today);
        const weekdayHead = ['日', '月', '火', '水', '木', '金', '土']
          .map((label, index) => `<span class="calendar-weekday ${index === 0 ? 'is-sun' : ''} ${index === 6 ? 'is-sat' : ''}">${label}</span>`)
          .join('');
        const monthBlocks = months
          .map((month) => {
            const cells = month.cells
              .map((cell) => {
                if (cell.type === 'blank') {
                  return '<span class="calendar-date-cell is-blank" aria-hidden="true"></span>';
                }

                const weekendClass = cell.date.getDay() === 0 ? 'is-sun' : cell.date.getDay() === 6 ? 'is-sat' : '';
                const todayClass = cell.dayKey === todayKey ? 'is-today' : '';
                const todayAttr = cell.dayKey === todayKey ? 'true' : 'false';
                if (!cell.bucket) {
                  return [
                    `<span class="calendar-date-cell ${weekendClass} ${todayClass}" data-is-today="${todayAttr}">`,
                    `  <span class="calendar-date-number">${cell.day}</span>`,
                    '</span>'
                  ].join('');
                }

                const lines = calendarCategoryDefs
                  .filter((meta) => meta.key !== 'all')
                  .map((meta) => {
                    const count = cell.bucket.counts.get(meta.key) || 0;
                    if (!count) return '';
                    return `<span class="calendar-date-item"><span class="calendar-date-item-logo">${escapeHtml(meta.logo)}</span><em>${count}</em></span>`;
                  })
                  .filter(Boolean)
                  .join('');

                return [
                  `<button class="calendar-date-cell is-event ${weekendClass} ${todayClass}" type="button" data-calendar-day="${escapeHtml(cell.dayKey)}" data-is-today="${todayAttr}">`,
                  '  <span class="calendar-date-head">',
                  `    <span class="calendar-date-number">${cell.day}</span>`,
                  '  </span>',
                  `  <span class="calendar-date-items">${lines}</span>`,
                  '</button>'
                ].join('');
              })
              .join('');
            return [
              '<section class="calendar-month">',
              `  <header class="calendar-month-header">${escapeHtml(month.title)}</header>`,
              `  <div class="calendar-weekdays">${weekdayHead}</div>`,
              `  <div class="calendar-grid">${cells}</div>`,
              '</section>'
            ].join('');
          })
          .join('');

        calendarList.innerHTML = monthBlocks;
        calendarList.querySelectorAll('[data-calendar-day]').forEach((button) => {
          button.addEventListener('click', () => {
            const dayKey = button.getAttribute('data-calendar-day') || '';
            openCalendarDayDrawer(dayKey);
          });
        });

        const todayNode = calendarList.querySelector('[data-is-today="true"]');
        if (todayNode) {
          window.requestAnimationFrame(() => {
            todayNode.scrollIntoView({ block: 'center', inline: 'nearest' });
          });
        }
      }

      function openCalendarPanel() {
        if (!calendarPanel) return;
        resetAutoOpen();
        closeMarkerActionBubble();
        closeCalendarDayDrawer(true);
        calendarPanel.classList.add('is-visible');
        calendarPanel.setAttribute('aria-hidden', 'false');
        phoneFrame.classList.add('is-calendar-open');
        phoneFrame.classList.add('is-calendar-page');
        renderCalendarPanel();
      }

      function closeCalendarPanel() {
        if (!calendarPanel) return;
        closeCalendarDayDrawer(true);
        calendarPanel.classList.remove('is-visible');
        calendarPanel.setAttribute('aria-hidden', 'true');
        phoneFrame.classList.remove('is-calendar-open');
        phoneFrame.classList.remove('is-calendar-page');
        syncBottomPanels();
      }

      function sideStatusText(status) {
        if (!status) return '調整中';
        if (status.mode === 'ongoing') return '開催中';
        if (status.mode === 'upcoming') return status.etaLabel ? `あと${status.etaLabel}` : 'まもなく';
        if (status.mode === 'ended') return '終了';
        return '調整中';
      }

      function sideStatusClass(status) {
        if (!status) return 'is-unknown';
        if (status.mode === 'ongoing') return 'is-ongoing';
        if (status.mode === 'upcoming') return 'is-upcoming';
        if (status.mode === 'ended') return 'is-ended';
        return 'is-unknown';
      }

      function miniProgressMode(status) {
        if (!status) return 'unknown';
        if (status.mode === 'ongoing') return 'ongoing';
        if (status.mode === 'upcoming') return 'upcoming';
        if (status.mode === 'ended') return 'ended';
        return 'unknown';
      }

      function miniProgressPercent(status) {
        if (!status) return 8;
        if (status.mode === 'ongoing') {
          return Math.round(Math.max(0, Math.min(1, Number(status.progress) || 0)) * 100);
        }
        if (status.mode === 'upcoming') {
          return Math.round(Math.max(0, Math.min(1, Number(status.waitProgress) || 0)) * 100);
        }
        if (status.mode === 'ended') {
          return 100;
        }
        return 8;
      }

      function shouldShowMiniProgress(status) {
        if (!status) return false;
        if (status.mode === 'upcoming') {
          const sec = Number(status.countdownSec) || 0;
          if (sec > 24 * 60 * 60) return false;
        }
        return true;
      }

      function miniProgressMarkup(status, variant) {
        if (!shouldShowMiniProgress(status)) return '';
        const mode = miniProgressMode(status);
        const scope = variant || 'base';
        const visualClass = mode === 'ongoing' ? 'detail-progress-ongoing' : 'detail-progress-upcoming';
        return [
          `<span class="mini-progress ${visualClass} mini-progress-${scope} mini-progress-mode-${mode}" aria-hidden="true">`,
          '  <div class="mini-progress-track status-track">',
          '    <span class="mini-progress-fill status-fill"></span>',
          '    <span class="mini-progress-endpoint status-endpoint">',
          '      <span class="mini-progress-he status-he">へ</span>',
          '    </span>',
          '  </div>',
          '</span>'
        ].join('');
      }

      function applyMiniProgressNode(rootNode, status) {
        if (!rootNode) return;
        const track = rootNode.querySelector('.mini-progress-track');
        const fill = rootNode.querySelector('.mini-progress-fill');
        const endpoint = rootNode.querySelector('.mini-progress-endpoint');
        const pct = miniProgressPercent(status);
        setProgressPosition(track, fill, null, endpoint, pct);
      }

      function applyWorldMode() {
        phoneFrame.classList.toggle('is-other-world-mode', sideDrawerState.worldMode);
      }

      function favoriteFilterDefs() {
        return [
          { key: 'all', label: 'すべて' },
          { key: 'planned', label: 'まだ訪れず' },
          { key: 'checked', label: '足あと済み' }
        ];
      }

      function isFavoriteDrawerOpen() {
        return Boolean(sideDrawerLayer && sideDrawerLayer.classList.contains('is-favorite-open'));
      }

      function setFavoriteDrawerOpen(nextOpen) {
        if (!sideDrawerLayer || !favoriteDrawer) return;
        const open = Boolean(nextOpen);
        sideDrawerLayer.classList.toggle('is-favorite-open', open);
        favoriteDrawer.setAttribute('aria-hidden', open ? 'false' : 'true');
      }

      function filteredFavoritePlaces() {
        const favorites = favoritePlaces();
        if (favoriteDrawerFilter === 'checked') {
          return favorites.filter((place) => placeStateOf(place.id).checkedIn);
        }
        if (favoriteDrawerFilter === 'planned') {
          return favorites.filter((place) => !placeStateOf(place.id).checkedIn);
        }
        return favorites;
      }

      function renderFavoriteDrawerContent() {
        if (!favoriteDrawerContent) return;
        const favorites = filteredFavoritePlaces();
        const allFavorites = favoritePlaces();
        const counts = {
          all: allFavorites.length,
          planned: allFavorites.filter((place) => !placeStateOf(place.id).checkedIn).length,
          checked: allFavorites.filter((place) => placeStateOf(place.id).checkedIn).length
        };

        const filters = favoriteFilterDefs()
          .map((item) => {
            const active = item.key === favoriteDrawerFilter;
            return [
              `<button class="favorite-filter ${active ? 'is-active' : ''}" type="button" data-favorite-filter="${item.key}">`,
              `  <span>${item.label}</span>`,
              `  <span class="favorite-filter-count">${counts[item.key] || 0}</span>`,
              '</button>'
            ].join('');
          })
          .join('');

        const cards = favorites
          .map((place) => {
            const status = resolveEventStatus(place);
            const range = `${status.startLabel || '--:--'} - ${status.endLabel || '--:--'}`;
            const progress = status.mode === 'ongoing' ? miniProgressMarkup(status, 'favorite') : '';
            const stateIcons = placeStateIconsMarkup(place.id, 'favorite');
            return [
              `<button class="favorite-drawer-item" type="button" data-favorite-place="${escapeHtml(place.id)}">`,
              '  <span class="favorite-drawer-item-head">',
              `    <span class="favorite-drawer-item-name">${escapeHtml(place.name)}</span>`,
              `    <span class="favorite-drawer-item-distance">${escapeHtml(resolvedDistanceText(place))}</span>`,
              '  </span>',
              '  <span class="favorite-drawer-item-foot">',
              `    <span class="favorite-drawer-item-time">${escapeHtml(range)}</span>`,
              `    ${stateIcons}`,
              '  </span>',
              progress ? `  ${progress}` : '',
              '</button>'
            ].join('');
          })
          .join('');

        favoriteDrawerContent.innerHTML = [
          '<div class="favorite-drawer-section">',
          '  <p class="favorite-drawer-muted">行きたい余韻と、歩いた足あとをここに。</p>',
          `  <div class="favorite-filters">${filters}</div>`,
          `  <div class="favorite-drawer-list">${cards || '<p class="favorite-drawer-muted">まだ栞は白紙です。</p>'}</div>`,
          '</div>'
        ].join('');

        favoriteDrawerContent.querySelectorAll('[data-favorite-filter]').forEach((button) => {
          button.addEventListener('click', () => {
            favoriteDrawerFilter = button.getAttribute('data-favorite-filter') || 'all';
            renderFavoriteDrawerContent();
          });
        });

        favoriteDrawerContent.querySelectorAll('[data-favorite-place]').forEach((button) => {
          const place = findPlaceById(button.getAttribute('data-favorite-place'));
          if (place) {
            applyMiniProgressNode(button.querySelector('.mini-progress'), resolveEventStatus(place));
          }
          button.addEventListener('click', () => {
            const target = findPlaceById(button.getAttribute('data-favorite-place') || '');
            if (!target) return;
            closeSideDrawerPanel();
            openQuickCard(target, 'favorite-drawer');
          });
        });
      }

      function renderFavoritesContent() {
        sideDrawerContent.innerHTML = [
          '<div class="drawer-section">',
          '  <p class="drawer-section-title">行きたい栞</p>',
          '  <p class="drawer-muted">左から、いまの栞をそっと開けます。</p>',
          '  <button id="openFavoriteDrawerAction" class="drawer-secondary-action" type="button">栞ドロワーをひらく</button>',
          '</div>'
        ].join('');
        const openButton = document.getElementById('openFavoriteDrawerAction');
        if (openButton) {
          openButton.addEventListener('click', () => {
            favoriteDrawerFilter = 'all';
            renderFavoriteDrawerContent();
            setFavoriteDrawerOpen(true);
          });
        }
      }

      function renderOtherWorldContent() {
        const modeText = sideDrawerState.worldMode ? '異世界モード ON' : '異世界モード OFF';
        const actionText = sideDrawerState.worldMode ? '通常モードへ戻す' : '異世界モードへ切り替え';
        sideDrawerContent.innerHTML = [
          '<div class="drawer-section">',
          '  <p class="drawer-section-title">もうひとつの世界</p>',
          `  <p class="drawer-muted">${modeText}</p>`,
          `  <button id="worldModeToggle" class="drawer-primary-action" type="button">${actionText}</button>`,
          '  <p class="drawer-muted">地図の色調と空気感だけを静かに切り替えます。</p>',
          '</div>'
        ].join('');

        const toggleButton = document.getElementById('worldModeToggle');
        if (toggleButton) {
          toggleButton.addEventListener('click', () => {
            sideDrawerState.worldMode = !sideDrawerState.worldMode;
            applyWorldMode();
            renderSideDrawerContent('other-world');
          });
        }
      }

      function renderNotificationsContent() {
        const rows = [
          {
            key: 'start',
            title: '開始前リマインド',
            hint: '開催直前にお知らせ'
          },
          {
            key: 'nearby',
            title: '周辺スポット通知',
            hint: '少し遠めの候補も通知'
          }
        ];
        const settings = rows
          .map((item) => {
            const checked = Boolean(sideDrawerState.notifications[item.key]);
            return [
              '<div class="drawer-setting-row">',
              '  <div class="drawer-setting-copy">',
              `    <p class="drawer-setting-title">${item.title}</p>`,
              `    <p class="drawer-setting-hint">${item.hint}</p>`,
              '  </div>',
              `  <button class="drawer-switch ${checked ? 'is-on' : ''}" type="button" data-notif-key="${item.key}" role="switch" aria-checked="${checked ? 'true' : 'false'}">`,
              '    <span class="drawer-switch-knob" aria-hidden="true"></span>',
              '  </button>',
              '</div>'
            ].join('');
          })
          .join('');

        sideDrawerContent.innerHTML = [
          '<div class="drawer-section">',
          '  <p class="drawer-section-title">通知設定</p>',
          `  <div class="drawer-settings">${settings}</div>`,
          '</div>'
        ].join('');

        sideDrawerContent.querySelectorAll('[data-notif-key]').forEach((button) => {
          button.addEventListener('click', () => {
            const key = button.getAttribute('data-notif-key');
            if (!key || !Object.prototype.hasOwnProperty.call(sideDrawerState.notifications, key)) return;
            sideDrawerState.notifications[key] = !sideDrawerState.notifications[key];
            renderSideDrawerContent('notifications');
          });
        });
      }

      async function copyTextToClipboard(text) {
        if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
          await navigator.clipboard.writeText(text);
          return true;
        }
        return false;
      }

      function renderContactContent() {
        const mail = 'contact@tsugie.app';
        sideDrawerContent.innerHTML = [
          '<div class="drawer-section">',
          '  <p class="drawer-section-title">お問い合わせ</p>',
          '  <a class="drawer-contact-link" href="mailto:contact@tsugie.app?subject=Tsugie%20問い合わせ">メールで連絡する</a>',
          '  <button id="copyContactMail" class="drawer-secondary-action" type="button">メールアドレスをコピー</button>',
          `  <p class="drawer-muted">${mail}</p>`,
          '</div>'
        ].join('');

        const copyButton = document.getElementById('copyContactMail');
        if (copyButton) {
          copyButton.addEventListener('click', async () => {
            const ok = await copyTextToClipboard(mail).catch(() => false);
            copyButton.textContent = ok ? 'コピーしました' : 'コピー失敗';
            window.setTimeout(() => {
              copyButton.textContent = 'メールアドレスをコピー';
            }, 1200);
          });
        }
      }

      function renderSideDrawerContent(menuId) {
        if (!sideDrawerContent) return;
        const nextMenu = String(menuId || activeMenuId || '').trim();
        if (!nextMenu) {
          activeMenuId = '';
          sideDrawerContent.innerHTML = [
            '<div class="drawer-section">',
            '  <p class="drawer-muted">項目をひとつ選ぶと、ここに静かにひらきます。</p>',
            '</div>'
          ].join('');
          return;
        }
        activeMenuId = nextMenu;
        if (nextMenu === 'other-world') {
          renderOtherWorldContent();
          return;
        }
        if (nextMenu === 'notifications') {
          renderNotificationsContent();
          return;
        }
        if (nextMenu === 'contact') {
          renderContactContent();
          return;
        }
        renderFavoritesContent();
      }

      function isSideDrawerOpen() {
        return Boolean(sideDrawerLayer && sideDrawerLayer.classList.contains('is-open'));
      }

      function setSideDrawerOpen(nextOpen) {
        if (!sideDrawerLayer || !topKaomoji) return;
        const open = Boolean(nextOpen);
        sideDrawerLayer.classList.toggle('is-open', open);
        sideDrawerLayer.setAttribute('aria-hidden', open ? 'false' : 'true');
        topKaomoji.setAttribute('aria-expanded', open ? 'true' : 'false');
        phoneFrame.classList.toggle('is-side-open', open);
        if (!open) {
          setThemePaletteOpen(false);
          setFavoriteDrawerOpen(false);
        }
      }

      function closeSideDrawerPanel() {
        setFavoriteDrawerOpen(false);
        setSideDrawerOpen(false);
      }

      function openSideDrawerPanel() {
        if (isDetailVisible()) return;
        closeMarkerActionBubble();
        setSideDrawerOpen(true);
        setActiveSideItem('');
      }

      function toggleSideDrawerPanel() {
        if (isSideDrawerOpen()) {
          closeSideDrawerPanel();
          return;
        }
        openSideDrawerPanel();
      }

      function setActiveSideItem(menuId) {
        const nextMenu = String(menuId || '').trim();
        activeMenuId = nextMenu;
        if (!sideDrawerItems.length) return;
        sideDrawerItems.forEach((item) => {
          item.classList.toggle('is-active', Boolean(nextMenu) && item.dataset.menuId === nextMenu);
        });
        if (nextMenu === 'favorites' && isSideDrawerOpen()) {
          favoriteDrawerFilter = 'all';
          renderFavoriteDrawerContent();
          setFavoriteDrawerOpen(true);
        } else {
          setFavoriteDrawerOpen(false);
        }
        renderSideDrawerContent(nextMenu);
      }

      function clearCurrentLocationMarker() {
        if (currentLocationPulseTimer) {
          window.clearInterval(currentLocationPulseTimer);
          currentLocationPulseTimer = null;
        }
        if (!currentLocationMarker) return;

        if (currentLocationMarker.halo) currentLocationMarker.halo.setMap(null);
        if (currentLocationMarker.core) currentLocationMarker.core.setMap(null);
        currentLocationMarker = null;
      }

      function createCurrentLocationFallbackElement() {
        const wrap = document.createElement('div');
        wrap.className = 'current-location is-fallback';
        wrap.id = 'currentLocationFallback';
        wrap.style.setProperty('--x', fallbackCurrentLocation.markerX);
        wrap.style.setProperty('--y', fallbackCurrentLocation.markerY);
        wrap.innerHTML = [
          '<span class="current-halo" aria-hidden="true"></span>',
          '<span class="current-core" aria-hidden="true"></span>',
          '<span class="current-label">現在地</span>'
        ].join('');
        return wrap;
      }

      function renderCurrentLocationOnGoogleMap(position) {
        if (!mapInstance || !window.google || !window.google.maps) return;
        clearCurrentLocationMarker();
        currentLocationPosition = { lat: position.lat, lng: position.lng };

        const pos = { lat: position.lat, lng: position.lng };
        const coreIcon = {
          path: window.google.maps.SymbolPath.CIRCLE,
          scale: 8,
          fillColor: '#0A84FF',
          fillOpacity: 1,
          strokeColor: '#FFFFFF',
          strokeWeight: 3
        };
        const buildHaloIcon = (scale, opacity) => ({
          path: window.google.maps.SymbolPath.CIRCLE,
          scale,
          fillColor: '#0A84FF',
          fillOpacity: opacity,
          strokeColor: '#0A84FF',
          strokeWeight: 1
        });

        const halo = new window.google.maps.Marker({
          map: mapInstance,
          position: pos,
          icon: buildHaloIcon(12, 0.22),
          clickable: false,
          zIndex: 820
        });
        const core = new window.google.maps.Marker({
          map: mapInstance,
          position: pos,
          icon: coreIcon,
          title: '現在地',
          zIndex: 880
        });

        let expanded = false;
        currentLocationPulseTimer = window.setInterval(() => {
          expanded = !expanded;
          halo.setIcon(buildHaloIcon(expanded ? 14 : 11.5, expanded ? 0.12 : 0.24));
        }, 760);

        currentLocationMarker = { core, halo };
      }

      async function resolveCurrentLocationPosition() {
        currentLocationPosition = {
          lat: fallbackCurrentLocation.lat,
          lng: fallbackCurrentLocation.lng
        };
        return currentLocationPosition;
      }

      function pulseFallbackCurrentLocation() {
        const node = document.getElementById('currentLocationFallback');
        if (!node) return;
        node.classList.remove('is-locating');
        window.requestAnimationFrame(() => {
          node.classList.add('is-locating');
          window.setTimeout(() => node.classList.remove('is-locating'), 760);
        });
      }

      function focusCurrentLocation(animated) {
        if (!mapInstance || !currentLocationPosition || !window.google || !window.google.maps) {
          pulseFallbackCurrentLocation();
          return;
        }
        const target = { lat: currentLocationPosition.lat, lng: currentLocationPosition.lng };
        if (animated) {
          mapInstance.panTo(target);
        } else {
          mapInstance.setCenter(target);
        }
        window.google.maps.event.addListenerOnce(mapInstance, 'idle', () => {
          mapInstance.panBy(0, -140);
        });
      }

      function formatDistanceLabel(km) {
        if (!Number.isFinite(km)) return '少し先';
        if (km < 1) return `${Math.max(80, Math.round(km * 1000))}m`;
        return `${km.toFixed(1)}km`;
      }

      function parseTimeParts(timeText) {
        const safe = String(timeText || '');
        const pieces = safe.split(':');
        const hour = Number(pieces[0]);
        const minute = Number(pieces[1]);
        if (!Number.isFinite(hour) || !Number.isFinite(minute)) return null;
        return { hour, minute };
      }

      function formatCountdownByGranularity(totalSeconds) {
        const safe = Math.max(0, Math.ceil(Number(totalSeconds) || 0));
        const days = Math.floor(safe / 86400);
        const hours = Math.floor(safe / 3600);
        const minutes = Math.floor((safe % 3600) / 60);
        const seconds = safe % 60;

        if (safe >= 86400) {
          return `${days}日${hours % 24}時間`;
        }
        if (safe >= 3600) {
          return `${hours}時間${minutes}分${seconds}秒`;
        }
        if (safe >= 300) {
          const mm = Math.floor(safe / 60);
          return `${mm}分${seconds}秒`;
        }
        return `${safe}秒`;
      }

      function dateFromParts(baseDate, hour, minute, dayOffset) {
        const d = new Date(baseDate);
        d.setDate(d.getDate() + dayOffset);
        d.setHours(hour, minute, 0, 0);
        return d;
      }

      function formatHm(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '--:--';
        return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
      }

      function ensureTestTimeline(place) {
        if (!place || !place.testTimeline || typeof place.testTimeline !== 'object') return null;
        if (testTimelineCache.has(place.id)) {
          return testTimelineCache.get(place.id);
        }

        const now = Date.now();
        const cfg = place.testTimeline;
        const mode = String(cfg.mode || '').toLowerCase();
        const durationSec = Math.max(60, Number(cfg.durationSec) || 60 * 60);
        let startMs = now;
        let endMs = now + durationSec * 1000;

        if (mode === 'upcoming') {
          const startInSec = Number(cfg.startInSec);
          startMs = now + (Number.isFinite(startInSec) ? startInSec : 20 * 60) * 1000;
          endMs = startMs + durationSec * 1000;
        } else if (mode === 'ongoing') {
          const elapsedSec = Number(cfg.elapsedSec);
          startMs = now - (Number.isFinite(elapsedSec) ? elapsedSec : durationSec / 3) * 1000;
          endMs = startMs + durationSec * 1000;
        } else if (mode === 'ended') {
          const endedAgoSec = Number(cfg.endedAgoSec);
          endMs = now - (Number.isFinite(endedAgoSec) ? endedAgoSec : 15 * 60) * 1000;
          startMs = endMs - durationSec * 1000;
        }

        const timeline = { startMs, endMs, durationSec };
        testTimelineCache.set(place.id, timeline);
        return timeline;
      }

      function resolveStatusByAbsoluteWindow(startDate, endDate, now) {
        const startMs = startDate.getTime();
        const endMs = endDate ? endDate.getTime() : null;
        const safeNow = now instanceof Date ? now : new Date();
        const nowMs = safeNow.getTime();

        if (endMs && nowMs >= startMs && nowMs <= endMs) {
          const totalMs = Math.max(1, endMs - startMs);
          const passedMs = Math.max(0, nowMs - startMs);
          const remainSec = Math.max(0, Math.ceil((endMs - nowMs) / 1000));
          const progress = Math.max(0, Math.min(1, passedMs / totalMs));
          return {
            mode: 'ongoing',
            leftLabel: `残り${formatCountdownByGranularity(remainSec)}`,
            rightLabel: `終了 ${formatHm(endDate)}`,
            startLabel: formatHm(startDate),
            endLabel: formatHm(endDate),
            etaLabel: formatCountdownByGranularity(remainSec),
            progress,
            waitProgress: 1,
            countdownSec: remainSec,
            startDate,
            endDate
          };
        }

        if (nowMs < startMs) {
          const diffSec = Math.max(1, Math.ceil((startMs - nowMs) / 1000));
          const etaClock = formatCountdownByGranularity(diffSec);
          const diffMinutes = Math.max(1, Math.ceil(diffSec / 60));
          const waitProgress = Math.max(0, Math.min(1, 1 - diffMinutes / 180));
          return {
            mode: 'upcoming',
            leftLabel: `開始まで${etaClock}`,
            rightLabel: `開始 ${formatHm(startDate)}`,
            startLabel: formatHm(startDate),
            endLabel: endDate ? formatHm(endDate) : '--:--',
            etaLabel: etaClock,
            progress: 0,
            waitProgress,
            countdownSec: diffSec,
            startDate,
            endDate
          };
        }

        return {
          mode: 'ended',
          leftLabel: '終了済み',
          rightLabel: endDate ? `終了 ${formatHm(endDate)}` : '終了',
          startLabel: formatHm(startDate),
          endLabel: endDate ? formatHm(endDate) : '--:--',
          etaLabel: '00:00:00',
          progress: 1,
          waitProgress: 1,
          countdownSec: 0,
          startDate,
          endDate
        };
      }

      function resolveEventStatus(place) {
        const now = new Date();
        const testTimeline = ensureTestTimeline(place);
        if (testTimeline) {
          const startDate = new Date(testTimeline.startMs);
          const endDate = new Date(testTimeline.endMs);
          return resolveStatusByAbsoluteWindow(startDate, endDate, now);
        }

        const startParts = parseTimeParts(place.startTime || '');
        if (!startParts) {
          return {
            mode: 'unknown',
            leftLabel: '時刻未定',
            rightLabel: '開始 未定',
            startLabel: '--:--',
            endLabel: '--:--',
            etaLabel: '',
            progress: 0,
            waitProgress: 0,
            countdownSec: 0
          };
        }

        const endParts = parseTimeParts(place.endTime || '');

        const windows = [-1, 0, 1].map((offset) => {
          const start = dateFromParts(now, startParts.hour, startParts.minute, offset);
          let end = null;
          if (endParts) {
            end = dateFromParts(now, endParts.hour, endParts.minute, offset);
            if (end.getTime() <= start.getTime()) {
              end.setDate(end.getDate() + 1);
            }
          }
          return { start, end };
        });

        const ongoing = windows.find((item) => item.end && now >= item.start && now <= item.end);
        if (ongoing) {
          return resolveStatusByAbsoluteWindow(ongoing.start, ongoing.end, now);
        }

        const candidateStarts = windows.map((item) => item.start).filter((date) => date.getTime() > now.getTime());
        candidateStarts.sort((a, b) => a.getTime() - b.getTime());
        const nextStart = candidateStarts[0] || dateFromParts(now, startParts.hour, startParts.minute, 1);
        let nextEnd = null;
        if (endParts) {
          nextEnd = new Date(nextStart);
          nextEnd.setHours(endParts.hour, endParts.minute, 0, 0);
          if (nextEnd.getTime() <= nextStart.getTime()) {
            nextEnd.setDate(nextEnd.getDate() + 1);
          }
        }
        return resolveStatusByAbsoluteWindow(nextStart, nextEnd, now);
      }

      function distanceKm(fromLat, fromLng, toLat, toLng) {
        const earthRadius = 6371;
        const toRad = (deg) => (deg * Math.PI) / 180;
        const dLat = toRad(toLat - fromLat);
        const dLng = toRad(toLng - fromLng);
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(toRad(fromLat)) * Math.cos(toRad(toLat)) * Math.sin(dLng / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return earthRadius * c;
      }

      function isInRect(place, rect) {
        return place.lat >= rect.south && place.lat <= rect.north && place.lng >= rect.west && place.lng <= rect.east;
      }

      function syncBottomPanels() {
        const quickVisible = quickCard.classList.contains('is-visible');
        const detailVisible = detailPanel.classList.contains('is-visible');
        const calendarVisible = isCalendarVisible();
        if (!nearbyCarousel) return;
        nearbyCarousel.classList.toggle('is-visible', !quickVisible && !detailVisible && !calendarVisible);
        nearbyCarousel.setAttribute('aria-hidden', quickVisible || detailVisible || calendarVisible ? 'true' : 'false');
      }

      function collectNearbyPlaces() {
        const recommended = recommendedPlace();
        let centerLat = recommended.lat;
        let centerLng = recommended.lng;
        let pool = [];

        if (mapInstance && window.google && window.google.maps && typeof mapInstance.getBounds === 'function') {
          const bounds = mapInstance.getBounds();
          const center = mapInstance.getCenter();

          if (bounds && center) {
            centerLat = center.lat();
            centerLng = center.lng();

            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const latSpan = Math.max(0.0012, Math.abs(ne.lat() - sw.lat()));
            const lngSpan = Math.max(0.0012, Math.abs(ne.lng() - sw.lng()));
            const expanded = {
              north: ne.lat() + latSpan * 1.15,
              south: sw.lat() - latSpan * 1.15,
              east: ne.lng() + lngSpan * 1.15,
              west: sw.lng() - lngSpan * 1.15
            };

            const visibleIds = new Set(
              places.filter((place) => bounds.contains({ lat: place.lat, lng: place.lng })).map((place) => place.id)
            );
            const inExpanded = places.filter((place) => place.id !== currentFocusPlaceId && isInRect(place, expanded));
            const justOutside = inExpanded.filter((place) => !visibleIds.has(place.id));
            pool = justOutside.length ? justOutside : inExpanded;
          }
        }

        if (!pool.length) {
          pool = places.filter((place) => place.id !== currentFocusPlaceId);
        }

        const sorted = pool
          .map((place) => ({
            ...place,
            distanceFromCenter: distanceKm(centerLat, centerLng, place.lat, place.lng)
          }))
          .sort((a, b) => a.distanceFromCenter - b.distanceFromCenter);

        return sorted.slice(0, 6);
      }

      function renderNearbyCarousel() {
        if (!nearbyTrack) return;
        const nearby = collectNearbyPlaces();
        nearbyTrack.innerHTML = '';

        if (!nearby.length) {
          return;
        }

        nearby.forEach((place) => {
          const colors = colorPair(place.name);
          const from = normalizeHex(colors[0]);
          const to = normalizeHex(colors[1]);
          const distance = formatDistanceLabel(place.distanceFromCenter);
          const status = resolveEventStatus(place);
          const progress = miniProgressMarkup(status, 'nearby');
          const stateIcons = placeStateIconsMarkup(place.id, 'nearby');

          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'nearby-item';
          button.style.setProperty('--nearby-from', from);
          button.style.setProperty('--nearby-to', to);
          button.innerHTML = [
            '<span class="nearby-top">',
            `  <span class="nearby-name">${place.name}</span>`,
            `  <span class="nearby-distance">${distance}</span>`,
            `  ${stateIcons}`,
            '</span>',
            '<span class="nearby-time">',
            `  <span class="nearby-eta">${status.leftLabel}</span>`,
            `  <span class="nearby-start">${status.rightLabel}</span>`,
            '</span>',
            progress
          ].join('');
          button.addEventListener('click', () => openQuickCard(place, 'nearby'));
          nearbyTrack.appendChild(button);
          applyMiniProgressNode(button.querySelector('.mini-progress'), status);
        });
      }

      function scheduleAutoOpen() {
        if (autoOpenScheduled) return;
        autoOpenScheduled = true;
        const target = recommendedPlace();
        autoOpenTimer = window.setTimeout(() => {
          if (isCalendarVisible() || isDetailVisible() || quickCard.classList.contains('is-visible')) return;
          openQuickCard(target, 'auto');
        }, 2200);
      }

      function resetAutoOpen() {
        if (autoOpenTimer) window.clearTimeout(autoOpenTimer);
        autoOpenTimer = null;
        autoOpenScheduled = false;
      }

      function refreshActiveStatusUI() {
        const activeQuickId = currentFocusPlaceId || currentDetailPlaceId;
        if (activeQuickId && quickCard.classList.contains('is-visible')) {
          const place = findPlaceById(activeQuickId);
          if (place) {
            const status = resolveEventStatus(place);
            quickDuration.textContent = quickDurationText(status);
            quickMeta.textContent = quickMetaText(place, status);
            applyPlaceStateIcons(quickStateIcons, place.id, 'quick');
            applyQuickProgress(status);
          }
        }

        if (isDetailVisible()) {
          const place = findPlaceById(currentDetailPlaceId || currentFocusPlaceId);
          if (place) {
            updateDetailPanel(place);
          }
        }

        if (isSideDrawerOpen() && activeMenuId === 'favorites') {
          renderSideDrawerContent(activeMenuId);
          if (isFavoriteDrawerOpen()) {
            renderFavoriteDrawerContent();
          }
        }

        if (isCalendarDayDrawerOpen()) {
          renderCalendarDayDrawerContent();
        }
      }

      function refreshAfterPlaceStateChange() {
        refreshActiveStatusUI();
        renderNearbyCarousel();
      }

      function startStatusTicker() {
        if (statusTicker) {
          window.clearInterval(statusTicker);
        }
        statusTicker = window.setInterval(refreshActiveStatusUI, 1000);
      }

      function renderMarkerOverlay(blockMapDrag) {
        fallbackLayer.hidden = false;
        fallbackLayer.classList.toggle('is-blocking', Boolean(blockMapDrag));
        fallbackLayer.innerHTML = '';
        closeMarkerActionBubble();
        markerHandles.clear();

        places.forEach((place) => {
          const markerEl = createMarkerElement(place);
          fallbackLayer.appendChild(markerEl);
          markerHandles.set(place.id, {
            element: markerEl,
            setActive(active) {
              markerEl.classList.toggle('is-active', active);
            },
            focus() {
              markerEl.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
          });
        });

        fallbackLayer.onclick = (event) => {
          if (event.target === fallbackLayer) {
            closeMarkerActionBubble();
          }
        };

        fallbackLayer.appendChild(createCurrentLocationFallbackElement());
        pulseFallbackCurrentLocation();
      }

      function resolveApiKey() {
        const queryKey = new URL(window.location.href).searchParams.get('gmapsKey');
        if (queryKey && queryKey.trim() !== '') return queryKey.trim();
        return String(config.gmapsKey || '').trim();
      }

      function loadGoogleMaps(apiKey) {
        return new Promise((resolve, reject) => {
          if (window.google && window.google.maps) {
            resolve(window.google.maps);
            return;
          }

          const callbackName = '__tsugieMapsReady';
          const timeoutId = window.setTimeout(() => {
            delete window[callbackName];
            reject(new Error('Google Maps の初期化がタイムアウトしました'));
          }, 9000);

          window[callbackName] = () => {
            window.clearTimeout(timeoutId);
            delete window[callbackName];
            resolve(window.google.maps);
          };

          const script = document.createElement('script');
          script.async = true;
          script.defer = true;
          script.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(apiKey)}&v=weekly&callback=${callbackName}`;
          script.onerror = () => {
            window.clearTimeout(timeoutId);
            delete window[callbackName];
            reject(new Error('Google Maps script の読み込みに失敗しました'));
          };
          document.head.appendChild(script);
        });
      }

      function createGoogleMarker(place) {
        const colors = colorPair(place.name);
        const from = normalizeHex(colors[0]);
        const to = normalizeHex(colors[1]);
        const position = { lat: place.lat, lng: place.lng };

        const defaultIcon = {
          path: window.google.maps.SymbolPath.CIRCLE,
          scale: 13.5,
          fillColor: from,
          fillOpacity: 0.95,
          strokeColor: to,
          strokeWeight: 3
        };
        const activeIconA = {
          path: window.google.maps.SymbolPath.CIRCLE,
          scale: 16,
          fillColor: from,
          fillOpacity: 0.95,
          strokeColor: '#FFFFFF',
          strokeWeight: 5
        };
        const activeIconB = {
          path: window.google.maps.SymbolPath.CIRCLE,
          scale: 18,
          fillColor: from,
          fillOpacity: 0.68,
          strokeColor: to,
          strokeWeight: 7
        };
        let pulseTimer = null;

        const marker = new window.google.maps.Marker({
          map: mapInstance,
          position,
          title: place.name,
          icon: defaultIcon,
          label: {
            text: 'へ',
            color: '#FFFFFF',
            fontSize: '13px',
            fontWeight: '800'
          }
        });

        marker.addListener('click', () => openMarkerActionBubble(place, 'google'));
        markerHandles.set(place.id, {
          marker,
          setActive(active) {
            if (!active) {
              if (pulseTimer) {
                window.clearInterval(pulseTimer);
                pulseTimer = null;
              }
              marker.setAnimation(null);
              marker.setIcon(defaultIcon);
              marker.setZIndex(undefined);
              marker.setLabel({
                text: 'へ',
                color: '#FFFFFF',
                fontSize: '11px',
                fontWeight: '700'
              });
              return;
            }

            marker.setZIndex(999);
            marker.setLabel({
              text: 'へ',
              color: '#FFFFFF',
              fontSize: '14px',
              fontWeight: '800'
            });
            marker.setIcon(activeIconA);

            if (window.google.maps.Animation && window.google.maps.Animation.BOUNCE) {
              marker.setAnimation(window.google.maps.Animation.BOUNCE);
              window.setTimeout(() => marker.setAnimation(null), 680);
            }

            if (!pulseTimer) {
              let glow = false;
              pulseTimer = window.setInterval(() => {
                glow = !glow;
                marker.setIcon(glow ? activeIconB : activeIconA);
              }, 420);
            }
          },
          focus() {
            if (mapInstance) mapInstance.panTo(position);
          }
        });
        return marker;
      }

      async function renderInteractiveMap(apiKey) {
        const location = await resolveCurrentLocationPosition();
        await loadGoogleMaps(apiKey);
        mapRoot.innerHTML = '';
        clearCurrentLocationMarker();
        markerHandles.clear();
        closeMarkerActionBubble();
        fallbackLayer.hidden = true;
        fallbackLayer.classList.remove('is-blocking');
        fallbackLayer.innerHTML = '';

        mapInstance = new window.google.maps.Map(mapRoot, {
          center: { lat: location.lat, lng: location.lng },
          zoom: DEFAULT_STREET_ZOOM,
          disableDefaultUI: true,
          gestureHandling: 'greedy',
          clickableIcons: false,
          styles: mapStyle
        });

        places.forEach((place) => {
          createGoogleMarker(place);
        });
        renderCurrentLocationOnGoogleMap(location);
        focusCurrentLocation(false);
        mapInstance.addListener('click', () => closeMarkerActionBubble());
        mapInstance.addListener('dragstart', () => closeMarkerActionBubble());

        window.google.maps.event.addListener(mapInstance, 'idle', () => {
          if (!quickCard.classList.contains('is-visible')) {
            renderNearbyCarousel();
          }
        });
      }

      function buildEmbedUrl(apiKey) {
        const target = recommendedPlace();
        const params = new URLSearchParams({
          key: apiKey,
          center: `${target.lat},${target.lng}`,
          zoom: String(DEFAULT_STREET_ZOOM),
          maptype: 'roadmap',
          language: 'ja',
          region: 'JP'
        });
        return `https://www.google.com/maps/embed/v1/view?${params.toString()}`;
      }

      function renderEmbedMap(apiKey) {
        mapRoot.innerHTML = '';
        clearCurrentLocationMarker();
        closeMarkerActionBubble();
        mapInstance = null;
        if (!apiKey) return;

        const iframe = document.createElement('iframe');
        iframe.className = 'google-map-embed';
        iframe.src = buildEmbedUrl(apiKey);
        iframe.title = '地図';
        iframe.loading = 'eager';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        iframe.setAttribute('aria-hidden', 'true');
        iframe.addEventListener('error', () => {
          showHint('Google Maps Embed の読み込みに失敗しました。サンプル背景とタップ可能なスポットを表示しています。');
        });
        mapRoot.appendChild(iframe);
      }

      function canStartQuickSwipe(target) {
        const isGrabber = target.closest('.sheet-grabber');
        const isActionButton = target.closest('.quick-actions');
        return Boolean(isGrabber || !isActionButton);
      }

      function canStartDetailSwipe(target) {
        const hitHandle = Boolean(target.closest('.detail-grabber') || target.closest('.detail-header'));
        if (hitHandle) return true;
        if (detailContent && detailContent.scrollTop > 4) return false;
        return true;
      }

      function shouldExpandDetailBySwipe(delta, startAt) {
        const elapsed = Date.now() - Number(startAt || Date.now());
        if (delta <= -44) return true;
        if (delta <= -20 && elapsed <= 220) return true;
        return false;
      }

      function shouldCloseQuickCardBySwipe(delta, startAt) {
        const elapsed = Date.now() - Number(startAt || Date.now());
        if (delta >= 56) return true;
        if (delta >= 26 && elapsed <= 220) return true;
        return false;
      }

      function resetQuickCardSwipe() {
        quickSwipeState = null;
        quickCard.classList.remove('is-dragging');
        quickCard.style.transform = '';
      }

      function handleQuickCardPointerDown(event) {
        if (!quickCard.classList.contains('is-visible') || isDetailVisible()) return;
        if (!canStartQuickSwipe(event.target)) return;

        quickSwipeState = {
          pointerId: event.pointerId,
          startY: event.clientY,
          deltaY: 0,
          startAt: Date.now()
        };
        quickCard.classList.add('is-dragging');
        quickCard.setPointerCapture(event.pointerId);
      }

      function handleQuickCardPointerMove(event) {
        if (!quickSwipeState || quickSwipeState.pointerId !== event.pointerId) return;
        const rawDelta = event.clientY - quickSwipeState.startY;
        const delta = Math.max(-190, Math.min(180, rawDelta));
        quickSwipeState.deltaY = delta;
        quickCard.style.transform = `translateY(${delta}px)`;
        if (Math.abs(delta) > 1) event.preventDefault();
      }

      function handleQuickCardPointerEnd(event) {
        if (!quickSwipeState || quickSwipeState.pointerId !== event.pointerId) return;
        const delta = quickSwipeState.deltaY;
        const startAt = quickSwipeState.startAt;
        resetQuickCardSwipe();

        if (shouldExpandDetailBySwipe(delta, startAt)) {
          const target = findPlaceById(currentFocusPlaceId || currentDetailPlaceId);
          if (target) {
            openDetailPanel(target, 'swipe');
          }
          return;
        }

        if (shouldCloseQuickCardBySwipe(delta, startAt)) {
          closeQuickCardPanel();
        }
      }

      function resetDetailSwipe() {
        detailSwipeState = null;
        detailPanel.classList.remove('is-dragging');
        detailPanel.style.transform = '';
      }

      function handleDetailPointerDown(event) {
        if (!isDetailVisible()) return;
        if (!canStartDetailSwipe(event.target)) return;
        detailSwipeState = {
          pointerId: event.pointerId,
          startY: event.clientY,
          deltaY: 0,
          startAt: Date.now()
        };
        detailPanel.classList.add('is-dragging');
        detailPanel.setPointerCapture(event.pointerId);
      }

      function handleDetailPointerMove(event) {
        if (!detailSwipeState || detailSwipeState.pointerId !== event.pointerId) return;
        const rawDelta = event.clientY - detailSwipeState.startY;
        const delta = Math.max(0, Math.min(260, rawDelta));
        detailSwipeState.deltaY = delta;
        detailPanel.style.transform = `translateY(${delta}px)`;
      }

      function handleDetailPointerEnd(event) {
        if (!detailSwipeState || detailSwipeState.pointerId !== event.pointerId) return;
        const delta = detailSwipeState.deltaY;
        resetDetailSwipe();
        if (delta >= 120) {
          closeDetailPanel(false);
        }
      }

      function openCurrentPlaceDetail() {
        const target = findPlaceById(currentFocusPlaceId || currentDetailPlaceId);
        if (!target) return;
        openDetailPanel(target, 'button');
      }

      function handleQuickCardTouchStart(event) {
        if (!quickCard.classList.contains('is-visible') || isDetailVisible()) return;
        if (!canStartQuickSwipe(event.target)) return;
        const touch = event.touches && event.touches[0];
        if (!touch) return;
        quickSwipeState = {
          pointerId: `touch-${touch.identifier}`,
          startY: touch.clientY,
          deltaY: 0,
          startAt: Date.now()
        };
        quickCard.classList.add('is-dragging');
      }

      function handleQuickCardTouchMove(event) {
        if (!quickSwipeState) return;
        const touch = event.touches && event.touches[0];
        if (!touch) return;
        const delta = Math.max(-190, Math.min(180, touch.clientY - quickSwipeState.startY));
        quickSwipeState.deltaY = delta;
        quickCard.style.transform = `translateY(${delta}px)`;
        if (Math.abs(delta) > 1) event.preventDefault();
      }

      function handleQuickCardTouchEnd() {
        if (!quickSwipeState) return;
        const delta = quickSwipeState.deltaY;
        const startAt = quickSwipeState.startAt;
        resetQuickCardSwipe();
        if (shouldExpandDetailBySwipe(delta, startAt)) {
          const target = findPlaceById(currentFocusPlaceId || currentDetailPlaceId);
          if (target) {
            openDetailPanel(target, 'swipe');
          }
          return;
        }

        if (shouldCloseQuickCardBySwipe(delta, startAt)) {
          closeQuickCardPanel();
        }
      }

      function handleDetailTouchStart(event) {
        if (!isDetailVisible()) return;
        if (!canStartDetailSwipe(event.target)) return;
        const touch = event.touches && event.touches[0];
        if (!touch) return;
        detailSwipeState = {
          pointerId: `touch-${touch.identifier}`,
          startY: touch.clientY,
          deltaY: 0,
          startAt: Date.now()
        };
        detailPanel.classList.add('is-dragging');
      }

      function handleDetailTouchMove(event) {
        if (!detailSwipeState) return;
        const touch = event.touches && event.touches[0];
        if (!touch) return;
        const delta = Math.max(0, Math.min(260, touch.clientY - detailSwipeState.startY));
        detailSwipeState.deltaY = delta;
        detailPanel.style.transform = `translateY(${delta}px)`;
      }

      function handleDetailTouchEnd() {
        if (!detailSwipeState) return;
        const delta = detailSwipeState.deltaY;
        resetDetailSwipe();
        if (delta >= 110) {
          closeDetailPanel(false);
        }
      }

      async function init() {
        setRandomKaomoji();
        initPlaceStates();
        const persistedScheme = loadPersistedColorScheme();
        if (persistedScheme) {
          activeColorScheme = persistedScheme;
        }
        applyColorScheme(activeColorScheme);
        const persistedAlphaRatio = loadPersistedThemeRatio(THEME_ALPHA_RATIO_STORAGE_KEY, 1);
        const persistedSaturation = loadPersistedThemeRatio(THEME_SATURATION_STORAGE_KEY, 1);
        setThemeRatios(persistedAlphaRatio, persistedSaturation, false);
        setThemePaletteOpen(false);
        setFavoriteDrawerOpen(false);
        applyWorldMode();
        setActiveSideItem(activeMenuId);
        startStatusTicker();
        const apiKey = resolveApiKey();
        resetAutoOpen();
        syncBottomPanels();

        if (apiKey) {
          try {
            await renderInteractiveMap(apiKey);
            renderNearbyCarousel();
            syncBottomPanels();
            scheduleAutoOpen();
            return;
          } catch (error) {
            renderEmbedMap(apiKey);
            renderMarkerOverlay(true);
            showHint('現在のキーには JS 地図の権限がないため、Embed モードに切り替えました。ずれ防止のためドラッグは固定されています。');
            renderNearbyCarousel();
            syncBottomPanels();
            scheduleAutoOpen();
            return;
          }
        }

        renderEmbedMap('');
        renderMarkerOverlay(true);
        showHint('gmapsKey が見つからないため、サンプル背景とタップ可能なスポットを表示しています。');
        renderNearbyCarousel();
        syncBottomPanels();
        scheduleAutoOpen();
      }

      closeQuickCard.addEventListener('click', closeQuickCardPanel);
      topKaomoji.addEventListener('click', toggleSideDrawerPanel);
      openCalendarButton.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        openCalendarPanel();
      });
      closeCalendarButton.addEventListener('click', closeCalendarPanel);
      calendarDayDrawerBackdrop.addEventListener('click', () => closeCalendarDayDrawer(true));
      closeCalendarDayDrawerButton.addEventListener('click', () => closeCalendarDayDrawer(true));
      sideDrawerBackdrop.addEventListener('click', () => {
        if (isFavoriteDrawerOpen()) {
          setFavoriteDrawerOpen(false);
          return;
        }
        closeSideDrawerPanel();
      });
      closeSideDrawer.addEventListener('click', closeSideDrawerPanel);
      closeFavoriteDrawer.addEventListener('click', () => setFavoriteDrawerOpen(false));
      toggleThemePalette.addEventListener('click', toggleThemePalettePanel);
      themeChips.forEach((chip) => {
        chip.addEventListener('click', () => {
          applyColorScheme(chip.dataset.themeScheme || 'fresh');
        });
      });
      if (themeAlphaRatioRange) {
        themeAlphaRatioRange.addEventListener('input', () => {
          setThemeRatios(Number(themeAlphaRatioRange.value) / 100, activeThemeSaturation, true);
        });
      }
      if (themeSaturationRange) {
        themeSaturationRange.addEventListener('input', () => {
          setThemeRatios(activeThemeAlphaRatio, Number(themeSaturationRange.value) / 100, true);
        });
      }
      sideDrawerItems.forEach((item) => {
        item.addEventListener('click', () => {
          setActiveSideItem(item.dataset.menuId || '');
        });
      });
      openDetailButton.addEventListener('click', openCurrentPlaceDetail);
      closeDetailButton.addEventListener('click', () => closeDetailPanel(false));
      closeDetailButton.addEventListener('pointerup', (event) => {
        event.preventDefault();
        event.stopPropagation();
        closeDetailPanel(false);
      });
      detailFocusButton.addEventListener('click', () => {
        const target = findPlaceById(currentFocusPlaceId || currentDetailPlaceId);
        if (target) {
          focusPlaceOnMap(target, true);
        }
      });
      if ('PointerEvent' in window) {
        quickCard.addEventListener('pointerdown', handleQuickCardPointerDown);
        quickCard.addEventListener('pointermove', handleQuickCardPointerMove);
        quickCard.addEventListener('pointerup', handleQuickCardPointerEnd);
        quickCard.addEventListener('pointercancel', handleQuickCardPointerEnd);
        detailPanel.addEventListener('pointerdown', handleDetailPointerDown);
        detailPanel.addEventListener('pointermove', handleDetailPointerMove);
        detailPanel.addEventListener('pointerup', handleDetailPointerEnd);
        detailPanel.addEventListener('pointercancel', handleDetailPointerEnd);
      } else {
        quickCard.addEventListener('touchstart', handleQuickCardTouchStart, { passive: true });
        quickCard.addEventListener('touchmove', handleQuickCardTouchMove, { passive: false });
        quickCard.addEventListener('touchend', handleQuickCardTouchEnd, { passive: true });
        quickCard.addEventListener('touchcancel', handleQuickCardTouchEnd, { passive: true });
        detailPanel.addEventListener('touchstart', handleDetailTouchStart, { passive: true });
        detailPanel.addEventListener('touchmove', handleDetailTouchMove, { passive: false });
        detailPanel.addEventListener('touchend', handleDetailTouchEnd, { passive: true });
        detailPanel.addEventListener('touchcancel', handleDetailTouchEnd, { passive: true });
      }
      locateButton.addEventListener('click', () => focusCurrentLocation(true));
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && isMarkerActionBubbleOpen()) {
          closeMarkerActionBubble();
          return;
        }
        if (event.key === 'Escape' && isCalendarDayDrawerOpen()) {
          closeCalendarDayDrawer(true);
          return;
        }
        if (event.key === 'Escape' && isCalendarVisible()) {
          closeCalendarPanel();
          return;
        }
        if (event.key === 'Escape' && isSideDrawerOpen()) {
          if (isFavoriteDrawerOpen()) {
            setFavoriteDrawerOpen(false);
            return;
          }
          closeSideDrawerPanel();
          return;
        }
        if (event.key === 'Escape' && isDetailVisible()) {
          closeDetailPanel(true);
          return;
        }
        if (event.key === 'Escape' && quickCard.classList.contains('is-visible')) {
          closeQuickCardPanel();
        }
      });
      init();
    </script>
  </body>
</html>
